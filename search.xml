<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>论文笔记|近期论文合集——超分辨CVPR2019</title>
      <link href="/2019/06/25/papers_21090626.html"/>
      <url>/2019/06/25/papers_21090626.html</url>
      <content type="html"><![CDATA[<p>下面是最近读的几篇论文的合集，主要是AAAI2018和CVPR2019。</p><a id="more"></a><p>###Learning a Single Convolutional Super-Resolution Network for Multiple Degradations</p><p>此文发于CVPR2018</p><p>题目：Learning a Single Convolutional Super-Resolution Network for Multiple Degradations<br>作者：Kai Zhang1;2;3, Wangmeng Zuo1, Lei Zhang2<br>1School of Computer Science and Technology, Harbin Institute of Technology, Harbin, China<br>2Dept. of Computing, The Hong Kong Polytechnic University, Hong Kong, China<br>3DAMO Academy, Alibaba Group</p><p>作者提出了一种可以handle不同降质模型的网络；维度拉伸策略处理LR图像/模糊和/噪声水平之间的不匹配问题。<br>先用PCA把模糊和和噪声水平到和LR图像一样大小。</p><div align="center"><img src="/2019/06/25/papers_21090626/SRMD_pca.png"></div><p>然后卷积+pixelshuffle恢复HR。</p><div align="center"><img src="/2019/06/25/papers_21090626/SRMD_overview.png"></div><p>处理方式较为粗暴。</p><p>###Blind Super-Resolution With Iterative Kernel Correction</p><p>此文发于CVPR2019</p><p>题目：Blind Super-Resolution With Iterative Kernel Correction<br>作者：Jinjin Gu1∗, Hannan Lu2∗, Wangmeng Zuo2, Chao Dong3<br>1The School of Science and Engineering, The Chinese University of Hong Kong, Shenzhen<br>2School of Computer Science and Technology, Harbin Institute of Technology, Harbin, China<br>3ShenZhen Key Lab of Computer Vision and Pattern Recognition, SIAT-SenseTime Joint Lab,<br>Shenzhen Institutes of Advanced Technology, Chinese Academy of Sciences</p><p>urlname: nonlocalGlobal_HSI_denoising_cvpr2019</p><p>本文提出一种迭代核相关方法来估计超分辨问题中的模糊核。文章清晰易懂，值得一读。<br>整体结构如下：</p><div align="center"><img src="/2019/06/25/papers_21090626/IKC_overview.png"></div><p>h为估计出的模糊核。</p><h3 id="Image-Super-Resolution-by-Neural-Texture-Transfer"><a href="#Image-Super-Resolution-by-Neural-Texture-Transfer" class="headerlink" title="Image Super-Resolution by Neural Texture Transfer"></a>Image Super-Resolution by Neural Texture Transfer</h3><p>此文发于CVPR2019，<a href="https://github.com/ZZUTK/SRNTT" target="_blank" rel="noopener">代码</a></p><p>题目： Image Super-Resolution by Neural Texture Transfer<br>作者：Zhifei Zhang Zhaowen Wang Zhe Lin Hairong Qi<br>ADOBE工作。</p><p>基本思想是patch match，从Ref图像中找到与LR最像的patch进行引导，不过由于Ref和LR是unpair的，所以匹配和融合都是在特征层面上操作。</p><p>网络结构没有看明白的一点是他的不同大小的分辨率是什么意思。如何保证swap取出的特征大小是相同的?</p><div align="center"><img src="/2019/06/25/papers_21090626/SRNTT_overview.png"></div><p>下面是纹理转换模块的内部结构，其实就是resnet+upsample.</p><div align="center"><img src="/2019/06/25/papers_21090626/SRNTT_NTT.png"></div><p>关于数据集制作，使用了网络搜索的图作为Ref。工作量有，提供了数据集，很棒。</p><div align="center"><img src="/2019/06/25/papers_21090626/SRNTTdataset.png"></div><p>至于结果，因为提供了ref图，所以可以从ref图中获取原有的LR图中几乎不可能恢复的信号，如下图的美国国旗，即使是SRGAN也不能从LR中恢复，但是本文由于有Ref，可以从Ref中获取极强的先验恢复美国国旗。（让我想到了华为P30拍月亮）。</p><div align="center"><img src="/2019/06/25/papers_21090626/SRNTT_result.png"></div><p>Loss有四个部分：mse，vggLOSS，生成loss，还有作者自己设计的纹理loss(这个应该是借鉴的STYLE tranfer)。</p><p>idea很自然，实验也充足。总的来说，不错的一篇工作。</p><h3 id="Feedback-Network-for-Image-Super-Resolution"><a href="#Feedback-Network-for-Image-Super-Resolution" class="headerlink" title="Feedback Network for Image Super-Resolution"></a>Feedback Network for Image Super-Resolution</h3><p>此文发于CVPR2019，<a href="https://github.com/Paper99/SRFBN_CVPR19" target="_blank" rel="noopener">代码</a></p><p>题目： Feedback Network for Image Super-Resolution<br>作者：Zhen Li1 Jinglei Yang2 Zheng Liu3 Xiaomin Yang1∗ Gwanggil Jeon4 Wei Wu1∗<br>1Sichuan University, 2University of California, Santa Barbara, 3University of British Columbia,<br>4Incheon National University</p><p>和2017cvpr Feedback networks很像，你懂得。<br>使用带约束的RNN隐状态作为反馈，课程学习策略进行训练。</p><p>所谓curriculum learning 就是先训练简单的数据，再训练复杂的数据。对应到本文，即对每一步的loss分配权重。</p><p>本文网络结构，看看2017cvpr  Feedback networks就明白了，作者把原文的ConvLSTM替换为了Feedback Block(FB).</p><div align="center"><img src="/2019/06/25/papers_21090626/SRFBN_overview.png"></div><p>这就是作者设计的FB模块：</p><div align="center"><img src="/2019/06/25/papers_21090626/FB.png"></div><p>总的来说，本文让我了解了Feedback Network和curriculum learning.Hhhh</p><h3 id="Dual-Residual-Networks-Leveraging-the-Potential-of-Paired-Operations-for-Image-Restoration"><a href="#Dual-Residual-Networks-Leveraging-the-Potential-of-Paired-Operations-for-Image-Restoration" class="headerlink" title="Dual Residual Networks Leveraging the Potential of Paired Operations for Image Restoration"></a>Dual Residual Networks Leveraging the Potential of Paired Operations for Image Restoration</h3><p>此文发于CVPR2019</p><p>题目： Dual Residual Networks Leveraging the Potential of Paired Operations for Image Restoration<br>作者：Xing Liuy Masanori Suganumayz Zhun Sunz Takayuki Okataniyz<br>yGraduate School of Information Sciences, Tohoku University zRIKEN Center for AIP</p><p>看到文章第一幅图猜想是篇以实验取胜的论文，嗯，可以参考简书:<a href="https://www.jianshu.com/p/f5b85a4e2b86" target="_blank" rel="noopener">文章学习40“Dual Residual Networks Leveraging the Potential of Paired Operations for Image Restoration”</a></p><p>总的来说，网络结构加加减减，实验很足，效果很好。</p><h3 id="“Double-DIP”-Unsupervised-Image-Decomposition-via-Coupled-Deep-Image-Priors"><a href="#“Double-DIP”-Unsupervised-Image-Decomposition-via-Coupled-Deep-Image-Priors" class="headerlink" title="“Double-DIP” :Unsupervised Image Decomposition via Coupled Deep-Image-Priors"></a>“Double-DIP” :Unsupervised Image Decomposition via Coupled Deep-Image-Priors</h3><p>此文发于CVPR2019</p><p>题目：“Double-DIP” :Unsupervised Image Decomposition via Coupled Deep-Image-Priors<br>作者：：Yossi Gandelsman Assaf Shocher Michal Irani<br>Dept. of Computer Science and Applied Mathematics<br>The Weizmann Institute of Science, Israel</p><p>这篇文章的基础是CVPR2018 Deep Image Prior.<a href="https://zhuanlan.zhihu.com/p/31595192" target="_blank" rel="noopener">论文解读</a></p><p>没什么好说的，你懂得。</p><div align="center"><img src="/2019/06/25/papers_21090626/DIP_overview.png"></div><h3 id="Unprocessing-Images-for-Learned-Raw-Denoising"><a href="#Unprocessing-Images-for-Learned-Raw-Denoising" class="headerlink" title="Unprocessing Images for Learned Raw Denoising"></a>Unprocessing Images for Learned Raw Denoising</h3><p>此文发于CVPR2019</p><p>题目：Unprocessing Images for Learned Raw Denoising<br>作者：Tim Brooks1 Ben Mildenhall2 Tianfan Xue1<br>Jiawen Chen1 Dillon Sharlet1 Jonathan T. Barron1<br>1Google Research, 2UC Berkeley</p><p>提出图像逆处理,将图像根据成像过程转换为调色、gamma调节、白平衡、色域转换等流程，通过直接处理原始图像传感器的原始测量数据来去噪。Darmstadt Noise数据集上得到了14%-38% 的提升和 9×-18×训练加速。</p><h3 id="Learning-Parallax-Attention-for-Stereo-Image-Super-Resolution"><a href="#Learning-Parallax-Attention-for-Stereo-Image-Super-Resolution" class="headerlink" title="Learning Parallax Attention for Stereo Image Super-Resolution"></a>Learning Parallax Attention for Stereo Image Super-Resolution</h3><p>此文发于CVPR2019</p><p>题目：Learning Parallax Attention for Stereo Image Super-Resolution<br>作者：Longguang Wang1, Yingqian Wang1, Zhengfa Liang2, Zaiping Lin1, Jungang Yang1, Wei An1, Yulan Guo1∗<br>1College of Electronic Science and Technology, National University of Defense Technology, China<br>2National Key Laboratory of Science and Technology on Blind Signal Processing, China</p><p>首先使用Res_ASPP提取特征,然后使用PAM(parallax attention module)计算相似性并对齐，最后聚合特征上采样得到SR。</p><div align="center"><img src="/2019/06/25/papers_21090626/PASSR_overview.png"></div><p>重点关注其PAM的设计以及loss设计。</p><h3 id="Enhancing-the-Spatial-Resolution-of-Stereo-Images-using-a-Parallax-Prior"><a href="#Enhancing-the-Spatial-Resolution-of-Stereo-Images-using-a-Parallax-Prior" class="headerlink" title="Enhancing the Spatial Resolution of Stereo Images using a Parallax Prior"></a>Enhancing the Spatial Resolution of Stereo Images using a Parallax Prior</h3><p>此文发于CVPR2018</p><p>题目：Enhancing the Spatial Resolution of Stereo Images using a Parallax Prior<br>作者：Daniel S. Jeon Seung-Hwan Baek Inchang Choi Min H. Kim∗<br>Korea Advanced Institute of Science and Technology (KAIST)</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|近期论文合集</title>
      <link href="/2019/06/25/papers_21090625.html"/>
      <url>/2019/06/25/papers_21090625.html</url>
      <content type="html"><![CDATA[<p>下面是最近读的几篇论文的合集，主要是AAAI2018和CVPR2019。</p><a id="more"></a><h3 id="Meta-SR"><a href="#Meta-SR" class="headerlink" title="Meta-SR"></a>Meta-SR</h3><p>此文发于CVPR2019</p><p>题目：Meta-SR: A Magnification-Arbitrary Network for Super-Resolution<br>作者：Xuecai Hu∗1,2 , Haoyuan Mu∗ 4, Xiangyu Zhang3, Zilei Wang1, Tieniu Tan1,2, Jian Sun3<br>1 University of Science and Technology of China<br>2 Center for Research on Intelligent Perception and Computing, NLPR, CASIA<br>3 Megvii Inc (Face++) 4 Tsinghua University</p><p>urlname:meta_sr_cvpr2019</p><p>使用meta-learning解决单模型连续尺度超分辨的的问题。<br>主要贡献是提出一个meta upscale 模块，根据放缩尺度r学习了不同的卷积核，但是具体如何实现上采样操作，矩阵乘法如何实现的没有搞懂，需要看代码。</p><p>网络结构如下图所示：</p><div align="center"><img src="/2019/06/25/papers_21090625/metasr_overview.png"></div><h3 id="MSI-fine-grain-recognition-of-powders"><a href="#MSI-fine-grain-recognition-of-powders" class="headerlink" title="MSI fine grain recognition of powders"></a>MSI fine grain recognition of powders</h3><p>此文发于CVPR2019。</p><p>题目：Multispectral Imaging for Fine-Grained Recognition of Powders on Complex Backgrounds<br>作者：Tiancheng Zhi, Bernardo R. Pires, Martial Hebert and Srinivasa G. Narasimhan<br>Carnegie Mellon University</p><p>urlname:MSI_powders_recongnition_cvpr2019</p><p>使用光谱图像对粉末进行分类，建立了粉末物体的数据集，方法貌似没有创新，属于工程应用。<br>【各种粉末名词劝退】</p><p>系统搭的有点意思，使用了三个相机拍摄：</p><div align="center"><img src="/2019/06/25/papers_21090625/powder_system.png"></div><p>粉末举例：</p><div align="center"><img src="/2019/06/25/papers_21090625/powder_eg.png"></div><h3 id="Hyperspectral-Imaging-with-Random-Printed-Mask"><a href="#Hyperspectral-Imaging-with-Random-Printed-Mask" class="headerlink" title="Hyperspectral Imaging with Random Printed Mask"></a>Hyperspectral Imaging with Random Printed Mask</h3><p>此文发于CVPR2019<br>题目：Hyperspectral Imaging with Random Printed Mask<br>作者：Yuanyuan Zhao1 Hui Guo1 Zhan Ma1 Xun Cao1 Tao Yue1,2 Xuemei Hu1<br>1Nanjing University, Nanjing, China<br>2NJU institute of sensing and imaging engineering, Nanjing, China</p><p>urlname: random_printed_HSI_cvpr2019</p><p>提出一种使用商用打印机打印掩膜的重建高光谱图像的方法。<br>实质是对mask的改进，不过脑洞还是挺大的。也通过硬件实现，有说服力。</p><p>Overview：</p><div align="center"><img src="/2019/06/25/papers_21090625/HSIrandom_mask.png"></div><h3 id="non-local-global-HSI-denoising"><a href="#non-local-global-HSI-denoising" class="headerlink" title="non-local-global HSI denoising"></a>non-local-global HSI denoising</h3><p>此文发于CVPR2019</p><p>题目：Non-local Meets Global: An Integrated Paradigm for Hyperspectral Denoising<br>作者：Wei He1, Quanming Yao2∗, Chao Li1, Naoto Yokoya1y, Qibin Zhao1<br>1RIKEN AIP 2HKUST</p><p>urlname: nonlocalGlobal_HSI_denoising_cvpr2019</p><h3 id="Multispectral-Transfer-Network"><a href="#Multispectral-Transfer-Network" class="headerlink" title="Multispectral Transfer Network"></a>Multispectral Transfer Network</h3><p>此文发于AAAI2018</p><p>题目：Multispectral Transfer Network:Unsupervised Depth Estimation for All-Day Vision<br>作者：Namil Kim,∗1,2 Yukyung Choi,∗1,3 Soonmin Hwang,1 In So Kweon1<br>1Korea Advanced Institute of Science and Technology (KAIST), Korea<br>2NAVER LABS Corp., Korea 3Clova, NAVER Corp., Korea</p><p>urlname: Multispectral_Transfer_Network_aaai2019</p><h3 id="unsupervised-cross-spectral-stereo-cycleGAN"><a href="#unsupervised-cross-spectral-stereo-cycleGAN" class="headerlink" title="unsupervised cross_spectral_stereo_cycleGAN"></a>unsupervised cross_spectral_stereo_cycleGAN</h3><p>此文发于AAAI2019，欢迎在文末留言交流。</p><p>题目：Unsupervised Cross-spectral Stereo Matching by Learning to Synthesize<br>作者：Mingyang Liang1;2∗, Xiaoyang Guo3∗, Hongsheng Li3, Xiaogang Wang3, You Song1 y<br>1Beihang University, Beijing, China<br>2SenseTime Research<br>3The Chinese University of Hong Kong, Hong Kong, China</p><p>urlname:cross_spec_stereo_cycleGAN_AAAI2019</p><div align="center"><img src="/2019/06/25/papers_21090625/eq3.png"></div><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|Multispectral Imaging for Fine-Grained Recognition of Powders on Complex Backgrounds</title>
      <link href="/2019/06/24/HS_FineGrain_cvpr2019.html"/>
      <url>/2019/06/24/HS_FineGrain_cvpr2019.html</url>
      <content type="html"><![CDATA[<p>写在前面：此文发于CVPR2019，欢迎在文末留言交流。</p><p>题目：Multispectral Imaging for Fine-Grained Recognition of Powders on Complex Backgrounds<br>作者：Tiancheng Zhi, Bernardo R. Pires, Martial Hebert and Srinivasa G. Narasimhan<br>Carnegie Mellon University<br>此文略读，没细看。</p><a id="more"></a><p>本文使用光谱图像对粉末进行细粒度识别。</p><p>粉末状物体，如药品，毒药，炸药，化妆品，食品添加剂，具有无定形，哑光，无颜色，无纹理，易与背景表面混合等特点。针对此挑战，作者提出了首个粉末物体识别的数据集以及对应的方法。</p><p>本文提出一种提高识别精度的同时，选择识别谱带的方法，显著缩短了采集时间。</p><div align="center"><img src="/2019/06/24/HS_FineGrain_cvpr2019/powder_eg.png">这一大堆粉末名词...头晕</div><p>作者使用了三个相机(RGB,近红外NIR,短波红外SWIR)，搭建系统如下：使用了分光镜*2+反射镜*1.</p><div align="center"><img src="/2019/06/24/HS_FineGrain_cvpr2019/system.png"></div><p>使用传统的光散射和吸收理论建模，用最近邻分类器balabla，用deeplab v3+做的分割。更加依赖于物质和光的物理模型，对图像的处理很少，看起来不像是做CV的人做的。</p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 光谱 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|Spectral Reconstruction from Dispersive Blur:A Novel Light Efficient Spectral Imager</title>
      <link href="/2019/06/23/Spectral_from_blur_cvpr2019.html"/>
      <url>/2019/06/23/Spectral_from_blur_cvpr2019.html</url>
      <content type="html"><![CDATA[<p>写在前面：此文发于CVPR2019，欢迎在文末留言交流。</p><p>题目：Spectral Reconstruction from Dispersive Blur: A Novel Light Efficient Spectral Imager<br>作者：Yuanyuan Zhao∗,1 Xuemei Hu∗,1 Hui Guo1 Zhan Ma1 Tao Yue1,2 Xun Cao1<br>1Nanjing University, Nanjing, China<br>2NJU institute of sensing and imaging engineering, Nanjing, China</p><a id="more"></a><p>作者提出一种利用DOB(difference of blur)获取多光谱图像的方法。在理论上证明了从单个棱镜blur图像以及一个场景中任意点光谱 恢复整幅高光谱图像的方法。</p><p>所谓DOB约束，即沿每个边缘的色散方向的色散模糊的导数正好是相邻区域的光谱差。特别地，多光谱图像重建问题可以被建模为N维线性方程组，并且通过图模型，作者理论证明了DoB约束提供了N-1个独立约束，所以需要额外的点来恢复光谱图像。作者引入边缘掩膜来获得边缘点的附加频谱信息，实现多光谱图像的全秩检索。</p><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>基于两个假设，1、图像可以被显示地分割为一系列区域，并且在每个区域内经过一个缩放因子光谱是可以达到均匀；2、每对相邻边沿分散方向的最大间距均大于分散尺寸。</p><h4 id="DoB约束"><a href="#DoB约束" class="headerlink" title="DoB约束"></a>DoB约束</h4><p>通过三棱镜，一个点的光谱可以分散到空间维度上。考虑两个区域$(i,j)$之间的边界，Dob可以表示为：<br>$$\nabla_\theta b=\delta_{ij}*(s_i-s_j)\tag{1}$$</p><p>$\delta$是冲击函数，$*$是卷积，$\nabla_\theta b表示$沿着投影角度$\theta$对图像强度b求导数。因此，如果我们知道冲击函数的位置，我们就可以从色散模糊的导数中得到光谱$s_i$和$s_j$的差。</p><p>对一幅色散模糊图像，我们可以定义边界矩阵A和DoB矩阵B去表示一个DOB约束，使用AB的每一行表示一个边界的DOB约束，一幅色散模糊图所有的DOB约束可以表示为：</p><p>$$AS=B \tag{2}$$</p><p>S表示光谱区域。A的每一行只有两个非零值(1,-1),下面证明A的秩为N-1，并且需要额外的光谱信息去全秩恢复S。</p><h4 id="光谱重建图理论"><a href="#光谱重建图理论" class="headerlink" title="光谱重建图理论"></a>光谱重建图理论</h4><p>为了讨论A的秩，作者建立了一个相关的图模型，$\mathcal{G}=(\mathcal{V},\mathcal{\varepsilon})$,其中，V是顶点集，每一个顶点代表一个表面。$\epsilon$表示边集合。</p><div align="center"><img src="/2019/06/23/Spectral_from_blur_cvpr2019/overview.png"></div><p>通过引入图模型，A的每一行对应$\epsilon$的一条边。由于图像中的每一个表面至少与另一个表面相邻，因此无向图G是连通的。有以下定理：</p><p><strong>Theorem 1 The rank of the edge matrix A exactly equals to the edge number of the spanning tree of its corresponding undirected connected graph G.</strong><br>边矩阵A的秩恰好等于其相应的无向连通图G生成树的边数。</p><p><strong>给出两个引理：1、连接图G和它的生成树G’有相同的谱解空间。<br>2、无向无环图G的边矩阵A，也就是树的边矩阵A，是满行秩。</strong></p><p>根据树的特性，有N个顶点的树G’有N-1条边，与树G’对应的边矩阵A’有N-1行，即A和A’的秩是小于等于N-1的，又根据引理2边矩阵是满秩的，所以，A和A’的秩是N-1。且A和A’的解空间是相同的。</p><p>###Point-wise Reconstruction Algorithm<br>如果给定分割后的图像，那么根据式(2)可以得重建每一个表面的光谱。</p><p>目标优化函数如下：<br>$$<br>E = E_f+\lambda_{Dob}E_{Dob}+\lambda_{side}E_{side}+\lambda_{cs}E_{cs}<br>$$</p><p><strong>其中，</strong><br>$$E_f=|G-P_g(S)|^2+|D-P_d(S)|^2$$</p><p>是对整体精度的约束，最基本的约束。</p><p><strong>DoB约束:</strong><br>$$E_{DoB} = |\nabla_{x,y}D-P_{d}(\nabla_{x,y}S)|^2$$</p><p><strong>边遮挡约束：</strong></p><p>$$E_{side}=|S\odot M|^2$$<br>M是边遮挡掩膜，$\odot $是点乘。</p><p><strong>交叉通道与稀疏正则化：</strong></p><p>$$E_{cs}=|\nabla_{x,y}S|<em>1+\Sigma_\lambda|\nabla</em>{x,y}S_\lambda(x,y)-\nabla_{x,y}G|_1$$<br>这个Loss主要是为了平滑空间域以及增强不同光谱通道上的相似的边界位置。在本文中，清晰的灰度图像可以为交叉通道与稀疏正则化提供参考图像。</p><p>后续通过引入辅助变量将此目标函数分解为两个子问题进行迭代求解，不提。</p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 光谱 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|Skin-based identification from multispectral image data using CNNs</title>
      <link href="/2019/06/21/skin_MSI_cvpr2019.html"/>
      <url>/2019/06/21/skin_MSI_cvpr2019.html</url>
      <content type="html"><![CDATA[<p>写在前面：此文发于CVPR2019，欢迎在文末留言交流。</p><p>题目：Skin-based identification from multispectral image data using CNNs<br>作者：Takeshi Uemori1 Atsushi Ito2 Yusuke Moriuchi2 Alexander Gatto1 Jun Murayama2<br>1Sony Europe B.V., Stuttgart, Germany 2Sony Corporation, Tokyo, Japan</p><div align="center"><img src="/2019/06/21/skin_MSI_cvpr2019/cartoon.png"></div><a id="more"></a><p>作者提出一种仅利用一块皮肤的高光谱图像进行生物识别的方法，是“首个使用手掌描述了位姿不变和对遮挡鲁棒的实时人体识别系统”。</p><p>根据文献中的光学考虑，感知到的颜色主要由真皮散射、黑色素和血管吸收组成，由于皮肤生色团浓度的不同，这些颜色在个体之间是不同的。</p><p>利用手的一个Patch(16*16)，作者的CNN模型可以对注册用户进行识别，而不使用手的形状作为额外信息。此模型也可以分辨左手右手+实时。</p><p>此外，作者探究了马赛克阵列光谱相机中 光谱与空间维度的trade-off。即在固定三维体积(光谱+空间)的情况下，如何分配光谱与空间分辨率使得分类的准确性最高。然而在实际中很难找到总分辨率相同但马赛克分辨率不同的相机，所以这个探究实验是仿真的。</p><h3 id="识别网络"><a href="#识别网络" class="headerlink" title="识别网络"></a>识别网络</h3><h3 id="WideResNet"><a href="#WideResNet" class="headerlink" title="WideResNet"></a>WideResNet</h3><p>作者使用了Wide-ResNet作为base network,在此网络的基础上，作者加入了spectral attention.</p><div align="center"><img src="/2019/06/21/skin_MSI_cvpr2019/wideres.jpeg"></div><h4 id="SE-Block"><a href="#SE-Block" class="headerlink" title="SE-Block"></a>SE-Block</h4><p>介绍SE-Block.</p><p>SEblock就是给不同通道赋不同的权重，具体操作是对U做squeeze（global average pooling，size=W*H），得到一维向量（长度为C），然后做excitation（类似RNN中的门机制，学习参数W来建立通道相关性），得到的结果作为U中C个channel的权重做scale。其目的是学习每个通道的重要程度，增强有用的特征抑制无用的特征(Selectively enhance useful features and suppress less useful ones )</p><div align="center"><img src="/2019/06/21/skin_MSI_cvpr2019/senet1.jpg"></div><div align="center"><img src="/2019/06/21/skin_MSI_cvpr2019/senet2.jpg"></div><h4 id="作者提出的网络结构"><a href="#作者提出的网络结构" class="headerlink" title="作者提出的网络结构"></a>作者提出的网络结构</h4><p>相比于原始的WideResNet,作者增加了SE-Block模块并且使用3D卷积替代2D卷积。网络结构没什么说的。</p><div align="center"><img src="/2019/06/21/skin_MSI_cvpr2019/overview.png"></div><div align="center"><img src="/2019/06/21/skin_MSI_cvpr2019/network.png"></div><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p>作者生成两个数据集，data#1,data#2.用来仿真和验证，感觉数据集的制作也是很大的一个贡献，如何设计实验验证自己的idea。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://zhuanlan.zhihu.com/p/29812913" target="_blank" rel="noopener">【深度学习从入门到放弃】Squeeze-and-Excitation Networks)</a></p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 光谱 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|Multispectral and Hyperspectral Image Fusion by MS/HS Fusion Net</title>
      <link href="/2019/06/19/MS_HS_fusion_cvpr2019.html"/>
      <url>/2019/06/19/MS_HS_fusion_cvpr2019.html</url>
      <content type="html"><![CDATA[<p>写在前面：此文发于CVPR2019，欢迎在文末留言交流。</p><p>题目：Multispectral and Hyperspectral Image Fusion by MS/HS Fusion Net<br>作者：Qi Xie1, Minghao Zhou1, Qian Zhao1, Deyu Meng1,∗ , Wangmeng Zuo2, Zongben Xu<br>1Xi’an Jiaotong University; 2Harbin Institute of Technology</p><a id="more"></a><p>作者提出了一种融合HR-MS和LR-HS的方法，从而生成HR-HS。作者提出的想融合模型考虑了低分辨率图像的观测模型和HR-HS的低秩特性。随后作者设计了一种迭代优化方法，并利用近端梯度法(Proximal Gradient Method, PG)求解此模型。最后作者将以上模型表示成深度网络形式(MS/HS Fusion Net)，通过卷积神经网络学习近端(proximal)操作子和模型参数。</p><p>直接恢复高分辨率的高光谱图像是一个病态的逆问题，通常操作是赋予先验。如，1、利用HR-MS训练的字典可以稀疏表示HR-HS的空间信息；2、假设HR-HS的局部空间平滑先验，使用全变分正则将其编码到优化模型中；3、除了探索空间先验，充分利用内部光谱相关性作为先验，使用低秩方法在光谱维度上编码先验以减少光谱畸变。</p><p>本文的贡献如下：1本文提出的融合模型不仅考虑了观测模型，并且使用了近似低秩先验结构以减少光谱畸变。2、将迭代策略集成到深度网络框架中。3、实验证明结果有效。</p><p>基于机器学习的方法1、使用稀疏编码在HR Patch上学习字典，然后学习从LR到HR的相关系数矩阵。2、稀疏矩阵分解学习LR光谱字典然后使用光谱字典和HRMS图像共同重建HRMS。3、非负矩阵分解。</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>基本模型：<br>$$Y=XR+N_y\tag{1}$$<br>$$Z=CX+N_y\tag{2}$$</p><p>其中$Y$是HRMS，$X$是HRHS，$R$为MS的光谱响应曲线，$N_y$是HRMS的噪声。<br>$Z$是LRHS，$C$是线性下采样操作，$N_z$是LRHS的噪声。</p><p>理论1：</p><div align="center"><img src="/2019/06/19/MS_HS_fusion_cvpr2019/th1.png"></div><p>又由于$\tilde{Y}=Y-N_y$,所以式(1)可等价于<br>$$X=YA+\hat{Y}B+N_x \tag{5}$$<br>其中，$Y$秩为s，$X$秩为r，$[Y,\hat{Y}]$秩为r。</p><p>同时存在以下结论：</p><div align="center"><img src="/2019/06/19/MS_HS_fusion_cvpr2019/cl2.png"></div><p>所以式(1)(2)可以表示成<br>$$Z=C(YA+\hat{Y}B)+N \tag{8}$$</p><p>这里Z的秩为r.</p><p>【一个疑问，这里的秩只针对的是光谱维度？理论上讲，lr相比较于HR也是降秩了的。但这里Z好像和X的秩是一样的？这种一样是因为$Z=CX$中C是线性下采样？】</p><div align="center"><img src="/2019/06/19/MS_HS_fusion_cvpr2019/fusmodel.png"></div><p>作者解释这种优化可以保持空间信息。</p><p>我自己来看，恢复HRHS可以从两个方向去看，一个是从HRMS进行光谱维度上采样，LRHS提供光谱维度的引导信息；另一个是从LRHS进行空间维度上采样，HRMS提供空间维度的引导信息。<br>两种方式孰优孰劣，直觉上空间维度的信息其实是更难恢复的。</p><h3 id="近端梯度法（Proximal-Gradient-Method-，PG）"><a href="#近端梯度法（Proximal-Gradient-Method-，PG）" class="headerlink" title="近端梯度法（Proximal Gradient Method ，PG）"></a>近端梯度法（Proximal Gradient Method ，PG）</h3><p>近端梯度法是一种特殊的梯度下降方法，主要用于求解目标函数不可微的最优化问题。如果目标函数在某些点是不可微的，那么该点的梯度无法求解，传统的梯度下降法也就无法使用。PG算法的思想是，使用临近算子作为近似梯度，进行梯度下降。</p><div align="center"><img src="/2019/06/19/MS_HS_fusion_cvpr2019/opt2net.png"></div><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><div align="center"><img src="/2019/06/19/MS_HS_fusion_cvpr2019/overview.png"></div><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://blog.csdn.net/qq547276542/article/details/78251779" target="_blank" rel="noopener">近端梯度法(Proximal Gradient Method, PG)</a></p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 光谱 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|Hyperspectral Image Super-Resolution with Optimized RGB Guidance</title>
      <link href="/2019/06/19/HSI_SR_RGB_cvpr2019.html"/>
      <url>/2019/06/19/HSI_SR_RGB_cvpr2019.html</url>
      <content type="html"><![CDATA[<p>写在前面：此文发于CVPR2019,欢迎在文末留言交流。</p><p>题目：Hyperspectral Image Super-Resolution with Optimized RGB Guidance<br>作者：Ying Fu1 Tao Zhang1 Yinqiang Zheng2 Debing Zhang3 Hua Huang<br>1Beijing Institute of Technology 2National Institute of Informatics 3DeepGlint</p><a id="more"></a><p>本文提出了非监督高光谱超分辨的网络结构，并加入了CSR优化层，去选择特定的优化。</p><p>作者提出来一种端到端的RGB引导高光谱超分辨的方法，可以有效地估计RGB空间和高光谱空间的非线性映射，并且利用了空间一致性。除此之外，作者还提出CSR优化层去根据给定的CSR数据集选择最优的CSR，甚至可以设计一个有利于优化RGB引导HSI超分辨任务的新CSR函数。</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>有低分辨率HSI$X_l$，高分辨率RGB$Y$，和待恢复HSI数据$X$。因此有<br>$$X_l=XH,~Y=CX\tag{1}$$<br>其中$H$为空间下采样，$C$为CSR函数。</p><p>现有的从高分辨率RGB和低分辨率HSI回复高分辨率HSI可以表示为<br>$$E(X)=E_d(X,X_l,Y)+\lambda E_s(X) \tag{2}$$</p><p>$E_d$表示为根据式(1)约束的恢复$X$，$E_s(\cdot)$为先验正则，之前的工作均假定有限的材料类型从而在稀疏假设下可以线性表示。非线性光谱表达可以显著地改善高光谱恢复的精度。</p><h3 id="RGB引导光谱CNN"><a href="#RGB引导光谱CNN" class="headerlink" title="RGB引导光谱CNN"></a>RGB引导光谱CNN</h3><p>网络结构如图1 所示。</p><p>首先使用式(1)对光谱图像进行光谱维度下采样，得到低分辨率的RGB图像，后使用CNN学习低分辨率RGB到低分辨率光谱图像之间的非线性映射，与此同时，RGB加到每层的特征上用于引导空间分辨率重建。<strong>有个疑问：既然$Y_l=CX_l$,降质过程（$C$）既然已知，为什么还要去学这个逆问题呢？</strong><br>这里为了学习到光谱信息的内在特征，使用了1*1的卷积核。Loss为MSEloss。</p><p>$$\mathcal{L}_s=|f(Y_l,\Theta)-X_l|^2<br>\tag{3}$$<br>由于网络参数对于高分辨率RGB是权值共享的，所以<br>$$X=f(Y,\Theta)\<br>X_l=f(Y_l,\Theta)\tag{4}$$</p><p>又根据式(1)，高分辨率HSI 与 经过线性映射的低分辨率HSI和高分辨率RGB是具有一致性的。<br>所以，联合式(1)(4),可以得到<br>$$\mathcal{L}_d=|Y-Cf(Y,\Theta)|^2+\tau_1|X_l-f(Y,\Theta)H|^2<br>\tag{5}$$</p><p>最终的loss为：</p><p>$$\mathcal{L}_sd = \mathcal{L}_d(\Theta)+\tau_2 \mathcal{L}_d(\Theta)+\eta_1|\Theta|^2$$</p><div align="center"><img src="/2019/06/19/HSI_SR_RGB_cvpr2019/overview.png">图1</div><h3 id="CSR优化"><a href="#CSR优化" class="headerlink" title="CSR优化"></a>CSR优化</h3><p>之前的研究解释了CSR对于HSI的恢复具有显著影响。</p><p>随后，作者提出了两种获取优化的CSR的方法。对于已知的RGB相机，作者设计了一个卷积层用于选择优化的CSR。除了CSR选择，CSR也可以在一定的物理条件约束下通过卷积层仿真。即，可以select or design .<br>由于本文的网络是非监督的，即理论上讲对于每一幅图像都可以得到一个新的CSR，但是这种方式对于同一个RGB相机意义不大。所以，对于一个RGB相机，只需要在一个数据集上优化得到CSR即可。</p><p>作者使用j个CSR函数对t个HSI生成RGB图像，得到$\mathcal{Y}<em>t = (Y</em>{1,t},Y_{2,t},\cdots,Y_{j-1,t},Y_{j,t})$，一副图像对应一个CSR函数，所以，选图像=选CSR。</p><p>图2(a)展示了CSR选择层的结构，表达成公式形式为式(6).本质上是对所有的CSR函数做了一组加权平均，权值是可学的卷积核。从基的角度理解，卷积核学习到的是CSR基的系数。【看文章描述这里后面还做了一个argmax()完成“选择”，而不是加权平均】</p><p>$$\hat{Y_t}=stack(V<em>\mathcal{Y_t}(R)),V</em>\mathcal{Y_t}(G)),V<em>\mathcal{Y_t}(B))<br>\tag{6}$$<br>上式中$V$为 1</em>1的卷积。</p><div align="center"><img src="/2019/06/19/HSI_SR_RGB_cvpr2019/CSRoptim.png">图2</div><p>下面又对CSR的非负性做了约束得到损失函数$\mathcal{L}_{cs}$</p><div align="center"><img src="/2019/06/19/HSI_SR_RGB_cvpr2019/lcs.png"></div><p>【这种方式和穷举所有csr算MSE，从所有的CSR中找出最接近的CSR有什么区别吗？只是用卷积形式表示出来？】</p><p>更进一步如图2(b)，作者提出可以用一组卷积核直接学习到CSR函数，并加入了平滑和非负约束得到$\mathcal{L}_{co}$。<br>【其实上一步就自然而然想到了CSR系数了啊】</p><div align="center"><img src="/2019/06/19/HSI_SR_RGB_cvpr2019/lco.png"></div><p>最终对应两种CSR层的设计方式(select or design)，就有对应的两种loss。<br>$$\mathcal{L} = \mathcal{L}<em>{cs}(V) + \tau_3\mathcal{L}</em>{sd}(\Theta).\<br>\mathcal{L} = \mathcal{L}<em>{co}(V) + \tau_4\mathcal{L}</em>{sd}(\Theta).\<br>$$<br>总结：这篇文章设计网络部分疑问较多。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 光谱 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|Hyperspectral Image Reconstruction Using a Deep Spatial-Spectral Prior</title>
      <link href="/2019/06/18/HSI_deep_spatial_spectral_prior.html"/>
      <url>/2019/06/18/HSI_deep_spatial_spectral_prior.html</url>
      <content type="html"><![CDATA[<p>写在前面：此文发于CVPR2019，欢迎在文末留言讨论。</p><p>题目：Hyperspectral Image Reconstruction Using a Deep Spatial-Spectral Prior<br>作者：Lizhi Wang1 Chen Sun1 Ying Fu1 Min H. Kim2 Hua Huang1<br>1Beijing Institute of Technology 2Korea Advanced Institute of Science and Technology</p><a id="more"></a><p>正则化是求解病态优化问题的一个基本方法，并且在高光谱图像重建中得到了广泛应用。但是以往基于正则化的方法往往需要手工设计且对变化范围大的场景不鲁棒。作者提出了一种结合数据驱动先验和基于优化网络的高光谱图像重建方案，在仿真和实物系统上达到了较高精度。</p><p>为了解决欠定重建问题，可以使用正则化引入图像先验，如全变分(TV)，sparsity,non-local similarity等正则化方法。但基于经验设计的正则化方法对多样的自然光谱图像处理能力差，需要手工微调参数且往往不能求取闭合解。近期提出的基于神经网络的压缩感知方法，LISTA,ADMM-NET,ISTA-NET等虽然可以避免迭代求解，但是仍然继承了稀疏先验这一特点，限制了一些层内的特征是稀疏的，这对于求解优化问题是不利的。同时，现有基于网络的重建方法只考虑了空间维度而忽略了光谱图维度，这相当于白白损失了一个维度的先验。</p><p>作者结合优化的内在结构(structure insight of the optimization)和神经网络出色的先验建模能力，1、首先学习先验的 正则化描述子。2、将描述子与优化方法结合表示成网络形式。</p><h4 id="HQS半二次方分裂"><a href="#HQS半二次方分裂" class="headerlink" title="HQS半二次方分裂"></a>HQS半二次方分裂</h4><p>首先需要介绍HQS算法：</p><p>有目标函数如下，其中$x$为待恢复图像。<br>$$<br>\hat{x}=\arg\min_x\frac{1}{2}|y-Hx|+\lambda\Phi(x)<br>$$</p><p>引入辅助变量$z$,<br>$$<br>\hat{x}=\arg\min_x\frac{1}{2}|y-Hx|^2+\lambda\Phi(z),s.t.~~z=x<br>$$</p><p>于是得到惩罚函数：</p><p>$$<br>\mathcal{L_\mu}(x,z)=\frac{1}{2}|y-Hx|+\lambda\Phi(z)+\frac{\mu}{2}|z-x|^2<br>$$</p><p>于是问题转化为迭代求解以下两式：</p><p>$$<br>x_{k+1}=\arg\min_x|y-Hx|+\mu|x-z_k|^2<br>$$</p><p>$$<br>z_{k+1} = \arg\min_z\frac{\mu}{2}|z-x_{k+1}|^2+\lambda\Phi(z)<br>$$</p><p>对应于本文要解决的压缩感知问题，当正则项不可微时，使用分离变量方法把正则项解耦出来，本文使用了HQS方法。如图1所示，对应的网络模型</p><div align="center"><img src="/2019/06/18/HSI_deep_spatial_spectral_prior/eq1.png">图1</div><p>从公式(7)(8)的角度考虑，可HQS方法分离了观测模型$\Phi$和超参先验$R(\cdot)$，所以可以使用卷积神经网络学习一个$S(\cdot)$来代替公式(8)的求解，如图2公式：</p><div align="center"><img src="/2019/06/18/HSI_deep_spatial_spectral_prior/eq2.png">图2</div>自然而然，一个卷积神经网络可以代替图2，网络结构如图3所示。<div align="center"><img src="/2019/06/18/HSI_deep_spatial_spectral_prior/priornet.png">图3</div><p>此网络的优点在于：1、考虑了空间维度和光谱维度；2、简单易学好训练。</p><p><img src="/2019/06/18/HSI_deep_spatial_spectral_prior/cassimodel.png" alt="cassimodel"></p><h3 id="优化与重建结合的方法"><a href="#优化与重建结合的方法" class="headerlink" title="优化与重建结合的方法"></a>优化与重建结合的方法</h3><p>与分离变量并进行迭代的方式相比，作者提出的方法整体考虑了观测模型和图像先验。<br>图1公式(7)中的f-子问题是一个最小二成问题，可以给出闭合解：</p><p><img src="/2019/06/18/HSI_deep_spatial_spectral_prior/eq3.png" alt="cassimodel"></p><p>利用共轭梯度法(conjugate gradient, CG)可以求解f-子问题，易推出(11)(12),</p><p><img src="/2019/06/18/HSI_deep_spatial_spectral_prior/eq4.png" alt="cassimodel"><br><img src="/2019/06/18/HSI_deep_spatial_spectral_prior/eq5.png" alt="cassimodel"></p><p>将先验生成网络嵌入到(12)，得到下图的网络。<br><img src="/2019/06/18/HSI_deep_spatial_spectral_prior/reconstructionnet.png" alt="reconstructionnet"></p><p>最终可以端到端训练进行重建。取得了STOA的结果。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.cnblogs.com/tornadomeet/p/3265225.html" target="_blank" rel="noopener">机器学习&amp;数据挖掘笔记_12（对Conjugate Gradient 优化的简单理解）</a></p><p><a href="https://www.cnblogs.com/wxl845235800/p/10734866.html" target="_blank" rel="noopener">HQS——Half Quadratic Splitting半二次方分裂</a></p><p>Learning Deep CNN Denoiser Prior for Image Restoration</p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 光谱 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小记|Valse2019</title>
      <link href="/2019/04/15/Valse2019.html"/>
      <url>/2019/04/15/Valse2019.html</url>
      <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Valse 2019</p><p>本次valse注册会议的人数达到了5000+，现场也异常火爆，许多workshop/tutorial开场前10min会场就已经坐满。而第一天的三维与深度学习的workshop则因为场地太小，主办方在已经开讲的情况下转移会场。这场汇集了华人CV青年学者的研讨会是当前深度学习与CV领域的一个缩影，异常火爆与拥挤，但也百花齐放，成果丰硕，不断碰撞出新的花火。</p><p>本届valse主题非常丰富，几乎包含了计算机视觉领域的所有热点，以弱监督、迁移学习、元学习、模型与网络设计、医学影像、三维重建为代表的主题是学界关注的重点。从公司workshop和展区来看，当前工业界并不怎么关注弱监督、迁移学习等概念，业界更关注CV与AI的直接产业化，如轻量级网络的设计，网络模型搜索，行人识别、语义分析、三维场景地图等与产品更近的技术）。</p><a id="more"></a><p>会议的很多workshop是同步进行的，所以有必要根据自己的兴趣主动做出取舍。当然，有时是因为会场爆满“被动”去听另一个完全听不懂的workshop。印象较深与略有收获主要集中在第一天与最后一天：第一天workshop“三维视觉与深度学习”，最后一日“深度学习模型设计”和poster环节。其他诸如“meta-learning”“弱监督语义分割”“single net work do more without retraining”等，我没有相关基础或因讲者进度过快推介自己的工作，听下来如蜻蜓点水，收获不大。</p><p>首先说下三维视觉的workshop。三维视觉是计算机视觉中最基础也是最经典的问题。因为转场等原因，我是从第二位国防科大的徐凯老师开始听的（后来听说第一个百度的一直在打广告，没听也不是太遗憾）。徐所讲的是通过hierarchial信息进行三维重建，介绍的工作很多，时间跨度较大，从2011年的工作一直到最近的工作，核心的思路是通过图模型对3D图像进行建模，关键是如何使用合适的结点表述以及连接关系对三维图像进行结构描述，徐在此基础上完成了从二维图像和恢复三维物体，并使用auto-encoder等结构完成对三维信息的重建、理解（分割）和生成。</p><div align="center"><img src="/2019/04/15/Valse2019/pic1.png"></div><div align="center"><img src="/2019/04/15/Valse2019/pic2.png"></div><p>第三位是清华的刘烨斌老师，主题是三维人体重建。关于人体的重建更多地是应用于娱乐方面，例如VR，影视、游戏、广告等（这时相关的炫酷应用吸引了观众的眼球）。人体动态重建的目标是能够达到大规模便捷实时的精准采集与重建。刘老师科普了这方面工作的发展：1、基于多视立体几何的方法具有重建质量高、支持任意拓扑等优点，但其实时性较差；2、基于三维模板的方法可以降低求解时间；3、基于统计模板的方法无任何人工预处理同时具有语义信息，但难以重建复杂的几何拓扑；4、而基于表面动态融合的方法无需人工预处理，甚至仅需单视点，但是以来实时深度相机或者深度计算性能，对于快速运动的人体效果差。随后介绍了他们的工作：单深度相机融合结合体态模板实时重建（double fusion，2+4），效果鲁棒性好，支持复杂拓扑结构和复杂纹理。（据我了解后来在double fusion的基础上将单深度相机扩展为多深度相机…）介绍的第二个工作是单深度相机语义化动态三维重建（MulayCap），视频展示效果仍旧酷炫。。。最后刘老师给出了未来三维人体重建领域的展望（如下ppt）。</p><div align="center"><img src="/2019/04/15/Valse2019/pic3.png"></div><div align="center"><img src="/2019/04/15/Valse2019/pic4.png"></div><p>下一位是自动化所模式国重的申抒含老师，报告更加科普。把三维场景重建的流程附加代表性结果讲了一遍，包括稀疏重建、稠密重建、语义建模、矢量建模等，最后介绍了几个应用。重建效果好的可怕。</p><div align="center"><img src="/2019/04/15/Valse2019/pic5.png"></div><div align="center"><img src="/2019/04/15/Valse2019/pic6.png"></div><div align="center"><img src="/2019/04/15/Valse2019/pic10.png"></div><p>最后一位是港科大的沈劭劼老师，最初在会议手册看到这个HKUT和报告题目“…drones”就猜测是大疆做的，ppt出来后果不其然，论文中有Dji的参与。内容是介绍利用无人机进行三维场景重建，更贴近SLAM。本来slam创新研究的门槛就已经较高了，这种结合无人机的工作更加困难，没有get到点。 </p><div align="center"><img src="/2019/04/15/Valse2019/pic7.png"></div><div align="center"><img src="/2019/04/15/Valse2019/pic8.png"></div>最后一日poster环节主要和曹讯老师的“hyperspectral imaging with random printed mask(cvpr2019)”的作者进行了讨论（讲解的是二作）。这篇文章的主要想法是通过在普通rgb相机前增加一个随机打印的彩色掩模来复原rgb图像，也是通过神经网络来恢复31个band的高光谱图像。相比于直接从rgb图像恢复高光谱，这种增加了随机色彩的掩模的成像系统具有更加准确的光谱精度。可以理解为增加了光谱基，使得恢复的高光谱图像精度更高。这个掩模是采用普通彩色打印机打印的，打印的图案为随机的彩色墨点，通过不同颜色墨点的混合，可以得到更多的色彩。个人感觉这是对于掩模式光谱相机的改进，通过与讲者的交流，在实现过程中有很多细节，实现这个系统还是要经过相当的积累与工作的。<p>这篇文章作者的另一篇工作“spectral reconstruction from dispersive blur: approaching full light throughput spectral imager”，通过分光镜获取灰度图像和因光路导致边缘blur的光谱图像，进行光谱重建。这篇文章通过图模型证明了实验可行性，没有看懂，且这篇文章和光学联系更加紧密。</p><div align="center"><img src="/2019/04/15/Valse2019/pic9.png"></div>总结与感受：1、poster现场来看，tracking和reid独占两排，来势汹汹。基于single Image的xx 的poster也较多.2、弱监督也需增加关注（两个弱监督workshop）3、强化学习并没有想象中的火热，只有极少数的文章提到了强化，强化学习的威力还没有展现出来。4、更少的信息输入（single image/view），更高维度的输出（3D）。三维相关领域是个可选方向，但是需要长时间的耕耘。5、了解了新概念meta-learning，感觉还在算法起步阶段。6、图模型和神经网络结合可能是未来图像相关算法的发展方向7、自己仍需努力。]]></content>
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> XJBX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux运行OpenGL</title>
      <link href="/2018/11/24/opengl1.html"/>
      <url>/2018/11/24/opengl1.html</url>
      <content type="html"><![CDATA[<p>写在前面：<br>在linux下开发OpenGL。<br>简单介绍OpenGL并安装，编写第一个程序。</p><p>环境：Ubuntu 16.04 LTS<br>Graphics:GT 730<br>gcc 5.4.0</p><a id="more"></a><h3 id="什么是OpenGL"><a href="#什么是OpenGL" class="headerlink" title="什么是OpenGL"></a>什么是OpenGL</h3><p>OpenGL 是一套由SGI公司发展出来的绘图函式库，它是一组 C 语言的函式，用于 2D 与 3D 图形应用程式的开发上。OpenGL 让程式开发人员不需要考虑到各种显示卡底层运作是否相同的问题，硬体由 OpenGL 核心去沟通，因此只要显示卡支援 OpenGL，那么程式就不需要重新再移植，而程式开发人员也不需要重新学习一组函式库来移植程式。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.首先安装编译器与基本函数库，一般情况下系统均已安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><p>2.其次安装 OpenGL Library</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libgl1-mesa-dev</span><br></pre></td></tr></table></figure><p>3.安装OpenGL Utilities</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libglu1-mesa-dev</span><br></pre></td></tr></table></figure><p>OpenGL Utilities 是一组建构于 OpenGL Library 之上的工具组，提供许多很方便的函式，使 OpenGL 更强大且更容易使用。</p><p>4.安装OpenGL Utility Toolkit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libglut-dev</span><br></pre></td></tr></table></figure><p>OpenGL Utility Toolkit 是建立在 OpenGL Utilities 上面的工具箱，除了强化了 OpenGL Utilities 的不足之外，也增加了 OpenGL 对于视窗介面支援。</p><p><strong>注意：在这一步的时候，可能会出现以下情况，shell提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">E: Unable to locate package libglut-dev</span><br></pre></td></tr></table></figure><p>将上述<code>$ sudo apt-get install libglut-dev</code>命令改成<code>$ sudo apt-get install freeglut3-dev</code>即可。</p><h3 id="第一个OpenGL程序"><a href="#第一个OpenGL程序" class="headerlink" title="第一个OpenGL程序"></a>第一个OpenGL程序</h3><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;GL/glut.h&gt;</span><br><span class="line"></span><br><span class="line">void init(void)</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(0.0, 0.0, 0.0, 0.0);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glOrtho(-5, 5, -5, 5, 5, 15);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    gluLookAt(0, 0, 10, 0, 0, 0, 0, 1, 0);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void display(void)</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glColor3f(1.0, 0, 0);</span><br><span class="line">    glutWireTeapot(3);</span><br><span class="line">    glFlush();</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(&amp;argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);</span><br><span class="line">    glutInitWindowPosition(0, 0);</span><br><span class="line">    glutInitWindowSize(300, 300);</span><br><span class="line">    glutCreateWindow(&quot;OpenGL 3D View&quot;);</span><br><span class="line">    init();</span><br><span class="line">    glutDisplayFunc(display);</span><br><span class="line">    glutMainLoop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  gcc -o test test.c -lGL -lGLU -lglut</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br></pre></td></tr></table></figure><p>结果：</p><div align="center"><img src="/2018/11/24/opengl1/opengl1.png"></div><p>期间编译时报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test.c: In function ‘main’:</span><br><span class="line">test.c:30:5: error: stray ‘\342’ in program</span><br><span class="line">     glutCreateWindow(“OpenGL 3D View”);</span><br><span class="line">     ^</span><br><span class="line">test.c:30:5: error: stray ‘\200’ in program</span><br><span class="line">test.c:30:5: error: stray ‘\234’ in program</span><br><span class="line">test.c:30:32: error: invalid suffix &quot;D&quot; on integer constant</span><br><span class="line">     glutCreateWindow(“OpenGL 3D View”);</span><br><span class="line">                                ^</span><br><span class="line">test.c:30:25: error: ‘OpenGL’ undeclared (first use in this function)</span><br><span class="line">     glutCreateWindow(“OpenGL 3D View”);</span><br><span class="line">                         ^</span><br><span class="line">test.c:30:25: note: each undeclared identifier is reported only once for each function it appears in</span><br><span class="line">test.c:30:32: error: expected ‘)’ before numeric constant</span><br><span class="line">     glutCreateWindow(“OpenGL 3D View”);</span><br><span class="line">                                ^</span><br><span class="line">test.c:30:32: error: stray ‘\342’ in program</span><br><span class="line">test.c:30:32: error: stray ‘\200’ in program</span><br><span class="line">test.c:30:32: error: stray ‘\235’ in program</span><br></pre></td></tr></table></figure><p>解决方法：把<code>glutCreateWindow(&quot;OpenGL 3D View&quot;);</code>中的中文<code>“”</code>换成英文<code>&quot;&quot;</code>。参考：<a href="https://stackoverflow.com/questions/2340930/stray-342-in-c-program" target="_blank" rel="noopener">Stray ‘\342’ in C++ program</a></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>本文内容主要参考<a href="https://blog.csdn.net/zhangliang_571/article/details/25241911" target="_blank" rel="noopener">Ubuntu 安装OpenGL</a><br><a href="https://blog.csdn.net/fengbingchun/article/details/80150544" target="_blank" rel="noopener">Ubuntu14.04下配置OpenGL及测试代码</a></p>]]></content>
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CUDA程序开发</title>
      <link href="/2018/11/16/CUDA.html"/>
      <url>/2018/11/16/CUDA.html</url>
      <content type="html"><![CDATA[<p>写在前面：<br>GPU并行计算和CUDA程序开发及优化 课堂笔记+课程作业<br>主要是一些小程序练手</p><a id="more"></a><h3 id="GPU相关知识"><a href="#GPU相关知识" class="headerlink" title="GPU相关知识"></a>GPU相关知识</h3><h4 id="GPU的计算模式"><a href="#GPU的计算模式" class="headerlink" title="GPU的计算模式"></a>GPU的计算模式</h4><p>在<strong>异构协同处理计算模型</strong>中将CPU与GPU结合起来加以利用。应用程序的串行部分在CPU上运行，而计算任务繁重的部分则由GPU的高性能计算来进行。从用户的角度来看，应用程序只是运行得更快了，获得了很好的性能提升。</p><h4 id="高性能计算机的-分类"><a href="#高性能计算机的-分类" class="headerlink" title="高性能计算机的 分类"></a>高性能计算机的 分类</h4><p>单指令流单数据流（ SISD）<br>• 单指令流多数据流（ SIMD）<br>• 多指令流单数据流（ MISD）<br>• 多指令流多数据流（ MIMD）</p><p>单独的高性能计算节点主要分为：<br>• 同构节点（仅采用CPU， Intel Xeon CPU、 AMD Opteron CPU）<br>• 异构节点（分为主机端和设备端，分别注重逻辑运算和浮点计算。</p><p>主流异构节点类型包括CPU+GPU和CPU+MIC<br>MIC： Many Integrated Core （Intel 集成众核）</p><h3 id="GPU硬件架构"><a href="#GPU硬件架构" class="headerlink" title="GPU硬件架构"></a>GPU硬件架构</h3><h4 id="NVIDIA不同架构产品"><a href="#NVIDIA不同架构产品" class="headerlink" title="NVIDIA不同架构产品"></a>NVIDIA不同架构产品</h4><p>不同GPU架构的设计理念、工艺水平等均不相同，相应的内部体系结构和性能也不相同。每一构架都对应大量产品</p><ul><li>Tesla</li><li>Fermi</li><li>Kepler</li><li>Maxwell</li><li>Pascal</li><li>Volta</li></ul><h4 id="GPU体系结构相关术语"><a href="#GPU体系结构相关术语" class="headerlink" title="GPU体系结构相关术语"></a>GPU体系结构相关术语</h4><ul><li>SP（ Streaming Processor） :流处理器是GPU运算的最基本计算单元。</li><li>SFU（ Special Function Unit） :特殊函数单元用来执行超越函数指令，比如正弦、余弦、平方根等函数。</li><li>Shader core（渲染核/着色器）， SP的另一个名称，又称为CUDA core，始于Fermi架构</li><li>DP （双精度浮点运算单元）</li><li>SM（ Streaming Multiprocessors） :流式多处理器是GPU架构中的基本计算单元，也是GPU性能的源泉，由 SP、DP、 SFU等运算单元组成。这是一个典型的阵列机，其执行方式为SIMT（单指令多线程），区别于传统的 SIMD（单指令流多数据流），能够保证多线程的同时执行</li><li>SPA（ Scalable streaming Processor Array）可扩展的流处理器阵列：所有处理核心和高速缓存的总和，包含所有的SM、 TPC、 GPC。与存储器系统共同组成GPU构架</li><li>MMC（ MeMory Controller）存储控制器：控制存储访问的单元，合并访存。每个存储控制器可以支持一定位宽的数据合并访存。</li><li>ROP（ raster operation processors）光栅操作单元</li><li>LD/ST（ Load/Store Unit）存储单元</li></ul><div align="center">![deviceQuery](./2018-11-16-CUDA/deviceQuery.png)deviceQuery</div>从图中可以看出，我的GPU为GT730，CUDA版本为9.0，GPU显存为2G，拥有384个CUDA核，GPU最大时钟频率为0.9Ghz，显存带宽为64位，每个block最多支持1024个线程。<p>与1080TI/k20相比，有些参数没差多少。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://blog.csdn.net/aaa958099161/article/details/82836846" target="_blank" rel="noopener">CSDN解读 RCAN Image Super-Resolution Using Very Deep Residual Channel Attention Networks-ECCV2018 </a></p>]]></content>
      
      <categories>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|DEEP3D</title>
      <link href="/2018/11/07/DEEP3D.html"/>
      <url>/2018/11/07/DEEP3D.html</url>
      <content type="html"><![CDATA[<p>写在前面：<br>Deep3d,由2D到3D视频转换，非常经典的视角重建。<a href="https://github.com/piiswrong/deep3d" target="_blank" rel="noopener">有码</a>。论文：<a href="https://arxiv.org/pdf/1612.00496.pdf" target="_blank" rel="noopener">Deep3D: Fully Automatic 2D-to-3D Video Conversion with Deep Convolutional Neural Networks</a>，作者：Junyuan Xie, Ross Girshick, Ali Farhadi<br>University of Washington</p><a id="more"></a><p>所以我们的方法并不是先预测一张深度图，然后用这张深度图通过一个单独的算法去重建缺失的视角，而是在同一神经网络中重新创建端到端的方法来训练它。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://blog.csdn.net/Xingyb14/article/details/83384653" target="_blank" rel="noopener">Deep3D 中文翻译及阅读笔记</a><br><a href="https://www.sohu.com/a/128924237_642762" target="_blank" rel="noopener">开源|如何使用CNN将视频从2D到3D进行自动转换（附源代码）</a></p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 深度估计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记|Unsupervised Monocular Depth Estimation with Left-Right Consistency</title>
      <link href="/2018/11/07/mono_depth.html"/>
      <url>/2018/11/07/mono_depth.html</url>
      <content type="html"><![CDATA[<p>写在前面：此文发于CVPR2017，并在<a href="http://visual.cs.ucl.ac.uk/pubs/monoDepth/" target="_blank" rel="noopener">项目主页</a>公布了代码。<br>本文中文翻译：<a href="https://zhuanlan.zhihu.com/p/29528596" target="_blank" rel="noopener">读Unsupervised Monocular Depth Estimation with LeftRight Consistency</a><br>代码中文解读：<a href="https://zhuanlan.zhihu.com/p/29664269" target="_blank" rel="noopener">[读源码] Unsupervised Monocular Depth Estimation with Left-Right Consistency</a><br>关于近几年单目深度估计的文章，可以参考<a href="https://www.zhihu.com/question/53354718/answer/207687177" target="_blank" rel="noopener">知乎用户的回答</a>。</p><p>题目：Unsupervised Monocular Depth Estimation with Left-Right Consistency<br>作者：Clement Godard     Oisin Mac Aodha     Gabriel J. Brostow<br>University College London</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h4><p>思考：人眼可以做到单目的原因是什么？</p><p>回答：人眼单目深度估计是基于极强的先验，这也限制了单目深度估计的应用场景。</p><p>“利用图像重建误差（image reconstruction loss）来最小化光度误差（类似于SLAM中的直接法）虽可以得到很好地图像重建结果（disparity），但得到深度预测结果非常差。”（不太了解SLAM直接法是什么）</p><p>本文主要讲无监督学习的方式估计深度。基本思想基于立体匹配中的左右一致性，即将一幅图warp到另一幅图定义loss。</p><p>保留问题：</p><ul><li>单目无监督深度的开山作是Depth Map Prediction from a Single Image using a Multi-Scale Deep Network（NIPS2014），第一篇CNN-based来做单目深度估计的文章。</li></ul><h4 id="other-works"><a href="#other-works" class="headerlink" title="other works"></a>other works</h4><ul><li>Deep3d: Fully automatic 2d-to-3d video conversion with deep convolutional neural network(ECCV2016),J. Xie, R. Girshick, and A. Farhadi.计算出每个像素的视差的概率分布，对像素所在行的所有视差进行加权求和，权重即为概率。</li><li>Unsupervised CNN for single view depth estimation: Geometry to the rescue.(ECCV2016),R. Garg, V. Kumar BG, and I. Reid. </li></ul><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li>新的loss，end2end的unsupervised monocular depth estimation网络</li><li>应用在了新的数据集上</li><li>对train loss和图像生成模型进行了评估。图像生成模型是指生成视差图的模型。</li></ul><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>网络结构：</p><p>encoder-decoder结构，包括长skip。通过一个带scale的sigmoid函数，将输出限制在(0,0.3*当前scale下的图像宽度)。<br>作者采用的激活为ELU（参看深度学习(1)-深度学习中的核函数（激活函数））。<br>decoder结构中，作者没有用广泛采用的deconvolution结构，而是用一个最近邻升采样+后续的卷积层的方式来做分辨率提升。<br>作者采用Adam模式（参见cs31n_lesson6_7/5.调参）来进行训练。</p><p>和一般视觉深度学习训练一样，数据增强（data augmentation）是必要的。</p><p>作者也尝试将encoder替换成Resnet50，而其他部分不变。 </p><p>LOSS：</p><div align="center">$$C_s=\alpha_{ap}(C^l_{ap}+C^r_{ap})+\alpha_{ds}(C^l_{ds}+C^r_{ds})+\alpha_{lr}(C^l_{lr}+C^r_{lr})$$</div><ul><li>$C_{ap}$:纹理loss，与输入图像纹理相关。<br><img src="/2018/11/07/mono_depth/Cap.png" alt="Cap"><br>$\alpha=0.8$<br>$C_{ap}$来自于Loss Functions for Neural Networks for Image Processing,也是主要起作用的部分！</li></ul><ul><li><p>$C_{ds}$:平滑loss<br><img src="/2018/11/07/mono_depth/Cds.png" alt="Cds"><br>直观理解，原图I梯度越大的地方，要求视差图d梯度越大；原图I梯度越小的地方（平滑），允许视差图d梯度越小（平滑）。</p></li><li><p>$C_{lr}$:左右一致性loss<br><img src="/2018/11/07/mono_depth/Clr.png" alt="Clr"></p></li></ul><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><p>35 ms for a 512*256 image on one modern GPU</p><h4 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h4><p>【作者在估计深度的过程中确实没有用到激光或者结构光的GT，但仍需要已知基线和焦距的双目图像对作为训练输入，测试时只需将单张图作为输入。感觉monocular有点牵强】</p><h4 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h4><ul><li>Dispnet &amp; FCN，本文使用的网络结构</li><li>STN ，作者warp图像的主要方式</li><li>本文提到另一个工作DeepStereo：从多个邻近视角选取像素合成新视角的图像。Deepstereo: Learning to predict new views from the world’s imagery. (CVPR2016)J. Flynn, I. Neulander, J. Philbin, and N. Snavely. </li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://blog.csdn.net/Kevin_cc98/article/details/78945802" target="_blank" rel="noopener">论文笔记-深度估计(5)Unsupervised Monocular Depth Estimation with Left-Right Consistency</a></p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 深度信息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记：SR总结</title>
      <link href="/2018/11/07/SR.html"/>
      <url>/2018/11/07/SR.html</url>
      <content type="html"><![CDATA[<p>写在前面：<br>这是一篇不太完善的CNN超分辨总结，整理了近年来深度学习在超分辨领域比较有代表性的工作，随缘更新。</p><a id="more"></a><p><strong>SRCNN</strong></p><p>(有码)</p><p>论文：</p><ul><li><a href="http://personal.ie.cuhk.edu.hk/~ccloy/files/eccv_2014_deepresolution.pdf" target="_blank" rel="noopener">Learning a Deep Convolutional Network for Image Super-Resolution, ECCV2014</a></li><li><a href="https://ieeexplore.ieee.org/document/7115171?arnumber=7115171" target="_blank" rel="noopener">Image Super-Resolution Using Deep Convolutional Networks, TPAMI2015</a></li></ul><p>项目主页：<a href="http://mmlab.ie.cuhk.edu.hk/projects/SRCNN.html" target="_blank" rel="noopener">http://mmlab.ie.cuhk.edu.hk/projects/SRCNN.html</a><br>作者：Chao Dong, Chen Change Loy, Kaiming He, Xiaoou Tang.</p><p><strong>VDSR</strong></p><p>论文：<a href="https://cv.snu.ac.kr/research/VDSR/VDSR_CVPR2016.pdf" target="_blank" rel="noopener">Accurate Image Super-Resolution Using Very Deep Convolutional Networks, CVPR2016</a><br>代码：</p><ul><li>official: <a href="https://cv.snu.ac.kr/research/VDSR/" target="_blank" rel="noopener">https://cv.snu.ac.kr/research/VDSR/</a></li><li>pytorch: <a href="https://github.com/twtygqyy/pytorch-vdsr" target="_blank" rel="noopener">https://github.com/twtygqyy/pytorch-vdsr</a></li><li>tensorflow: <a href="https://github.com/Jongchan/tensorflow-vdsr" target="_blank" rel="noopener">https://github.com/Jongchan/tensorflow-vdsr</a></li></ul><p>作者：Jiwon Kim Jung Kwon Lee Kyoung Mu Lee </p><p><strong>ESPCN</strong><br>论文：<a href="https://arxiv.org/pdf/1609.05158.pdf" target="_blank" rel="noopener">Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network，CVPR2016</a><br>代码：<a href="https://github.com/Tetrachrome/subpixel" target="_blank" rel="noopener">https://github.com/Tetrachrome/subpixel</a><br>作者：Wenzhe Shi, Jose Caballero, Ferenc Huszar, Johannes Totz, Andrew P. Aitken,Rob Bishop, Daniel Rueckert, Zehan Wang</p><p><strong>SRGAN</strong></p><p>论文：<a href="http://openaccess.thecvf.com/content_cvpr_2017/papers/Ledig_Photo-Realistic_Single_Image_CVPR_2017_paper.pdf" target="_blank" rel="noopener">Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Network, CVPR2017</a><br>代码：</p><ul><li>github(tensorflow): <a href="https://github.com/zsdonghao/SRGAN" target="_blank" rel="noopener">https://github.com/zsdonghao/SRGAN</a></li><li>github(tensorflow): <a href="https://github.com/buriburisuri/SRGAN" target="_blank" rel="noopener">https://github.com/buriburisuri/SRGAN</a></li><li>github(torch): <a href="https://github.com/junhocho/SRGAN" target="_blank" rel="noopener">https://github.com/junhocho/SRGAN</a></li><li>github(caffe): <a href="https://github.com/ShenghaiRong/caffe_srgan" target="_blank" rel="noopener">https://github.com/ShenghaiRong/caffe_srgan</a></li><li>github(tensorflow): <a href="https://github.com/brade31919/SRGAN-tensorflow" target="_blank" rel="noopener">https://github.com/brade31919/SRGAN-tensorflow</a></li><li>github(keras): <a href="https://github.com/titu1994/Super-Resolution-using-Generative-Adversarial-Networks" target="_blank" rel="noopener">https://github.com/titu1994/Super-Resolution-using-Generative-Adversarial-Networks</a></li><li>github(pytorch): <a href="https://github.com/ai-tor/PyTorch-SRGAN" target="_blank" rel="noopener">https://github.com/ai-tor/PyTorch-SRGAN</a><br>作者：Christian Ledig, Lucas Theis, Ferenc Huszar, Jose Caballero, Andrew Cunningham,Alejandro Acosta, Andrew Aitken, Alykhan Tejani, Johannes Totz, Zehan Wang, Wenzhe Shi（Twitter的十一个作者，和deepmind的二十几个作者还有差距:)  ）</li></ul><p><strong>RCAN</strong><br>论文：<a href="https://eccv2018.org/openaccess/content_ECCV_2018/papers/Yulun_Zhang_Image_Super-Resolution_Using_ECCV_2018_paper.pdf" target="_blank" rel="noopener">RCAN Image Super-Resolution Using Very Deep Residual Channel Attention Networks-ECCV2018</a><br>代码：github(official-pytorch)<a href="https://github.com/yulunzhang/RCAN" target="_blank" rel="noopener">https://github.com/yulunzhang/RCAN</a><br>作者：Yulun Zhang, Kunpeng Li, Kai Li, Lichen Wang, Bineng Zhong, Yun Fu</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://blog.csdn.net/edogawachia/article/details/79731091" target="_blank" rel="noopener">GAN相关：SRGAN，GAN在超分辨率中的应用</a><br><a href="https://blog.csdn.net/aBlueMouse/article/details/78710553" target="_blank" rel="noopener">从SRCNN到EDSR，总结深度学习端到端超分辨率方法发展历程</a><br><a href="https://github.com/YapengTian/Single-Image-Super-Resolution" target="_blank" rel="noopener">A collection of high-impact and state-of-the-art SR methods</a><br><a href="https://arxiv.org/abs/1706.09077" target="_blank" rel="noopener">Super-Resolution via Deep Learning</a><br><a href="https://blog.csdn.net/aaa958099161/article/details/82836846" target="_blank" rel="noopener">CSDN解读 RCAN Image Super-Resolution Using Very Deep Residual Channel Attention Networks-ECCV2018 </a></p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 超分辨 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记：Zoom and Learn:Generalizing Deep Stereo Matching to Novel Domains</title>
      <link href="/2018/10/22/zoom_and_learn_stereo_domin.html"/>
      <url>/2018/10/22/zoom_and_learn_stereo_domin.html</url>
      <content type="html"><![CDATA[<p>写在前面：CVPR2018，针对双目匹配在训练和实际应用中存在的domin transfer问题。<br>由于商业原因，作者只公布了测试代码。</p><div align="center">![phone](paper_Zoom and Learn/phone.png)</div><p>题目：Zoom and Learn: Generalizing Deep Stereo Matching to Novel Domains<br>作者：Jiahao Pang$^1$ Wenxiu Sun$^1$ ChengxiYang$^1$ JimmyRen$^1$ RuichaoXiao$^1$ JinZeng$^1$ LiangLin$^{1,2}$<br>$^1$SenseTime Research $^2$Sun Yat-sen University</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h4><p>立体匹配通用难点：基于CNN的立体匹配的一个难点在于训练得到的立体匹配模型往往不能使用在真实场景(new domain)中，即两个domain之间存在gap(这也是CNN的一个通病)。</p><p>两个常识：</p><ul><li>预训练好的模型在新domain直接使用会在边界出现artifacts</li><li>使用up-sampled的图像对生成disparity会带来额外的细节</li></ul><p>基于这两个常识，作者使用迭代优化的方式在 让CNN得到高空间分辨率的输出(常识2) 的同时，利用graph Laplacian regularization保留边界且平滑边界的artifacts(常识1).</p><p>作者在手机拍摄的日常场景和KITTI上进行了实验验证。</p><h4 id="other-works"><a href="#other-works" class="headerlink" title="other works"></a>other works</h4><p>监督：</p><ul><li>DispNet,first end-to-end CNN stereo matching</li><li>CRL:A two-stage convolutional neural network for stereo matching. (ICCVW2017)</li><li>GC-NET:End-to-end learning of geometry and context for deep stereo regression.（ICCV2017）</li><li>DRR:Detect, replace, refine: Deep structured prediction for pixel wise labeling.(CVPR2017)</li></ul><p>半监督：</p><ul><li>Unsupervised monocular depth estimation with left-right consistency(CVPR2017)</li><li>Semi-supervised deep learning for monocular depth map prediction.(CVPR2017)</li><li>Self-supervised learning for stereo matching with self-improving ability.arXiv</li><li>Unsupervised learning of stereo matching.(ICCV2017)‘</li></ul><p>目前常用方式，合成数据集上训练后再在有GT的目标数据上finetune.</p><ul><li>End-to-end learning of geometry and context for deep stereo regression.（ICCV2017）</li><li>A large dataset to train convolutional networks for disparity, optical flow, and scene flow estimation.(CVPR2016)</li><li>A two-stage convolutional neural network for stereo matching.(ICCVW2017)</li></ul><p>Graph Laplacian regularization.</p><ul><li>这里引用集中在denosing方面，不看了。</li></ul><p>Iterative regularization/filtering</p><ul><li>引用为image restoration方面，作者将其引入到CNN。</li><li>作者还专门强调，不同于堆叠CNN，这里的iteration是在训练过程中的iteration.</li></ul><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>尺度多样性。</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><div align="center">![Algorithm](paper_Zoom and Learn/Algorithm.png)</div><h4 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h4><p><strong>定量评价</strong><br>这里的评价指标很有意思。由于作者在三个数据集上进行了验证，有一个是和训练集相同的FlyingThings3D-80,另外一个是没有GT的手机拍摄的数据集，还有KITTI2015。</p><div align="center">![performace1](paper_Zoom and Learn/performance1.png)![performace2](paper_Zoom and Learn/performance2.png)</div><p>EPE:End-point-End<br>3ER:three-pixel error rate<br>这里所谓的PSNR和SSIM是利用disparity和右图生成的左图与真正的左图计算的PSNR和SSIM。左右图warp后肯定会有occlusion的存在，不知道这么PSNR意义是否很大。</p><p><strong>视觉指标</strong></p><div align="center">![result1](paper_Zoom and Learn/result1.png)![result2](paper_Zoom and Learn/result2.png)</div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结起来，使用了graph Laplacian 保持物体的边界，具体方法迭代patch。大概就这样。<br>与另一篇相似的工作Unsupervised Adaptation for Deep Stereo相比，指标高了那么一diudiu。</p><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>Unsupervised Adaptation for Deep Stereo<br>代码：<a href="https://github.com/AlessioTonioni/dispflownet-tf" target="_blank" rel="noopener">tensorflow版本</a>、<a href="https://github.com/CVLAB-Unibo/Unsupervised-Adaptation-for-Deep-Stereo" target="_blank" rel="noopener">caffe版本</a></p><p>文章有何贡献：本文提出了一种新的 fine-tuning 的方法使在大量合成数据上训练的 DispNet 可以迁移到无 groudtruth 或者只有极少量的 groundtruth 的实际数据集上。</p><p>本文研究的问题有何价值：双目深度估计的标签现实中很难获得，本文提出的 fine-tuning 方法可以在没 有groundtruth 的情况下将模型迁移过来。</p><p>所研究问题有何困难：如何获得可靠的监督信息来 fine-tune。</p><p>本文的解决思路是怎样的：文章受在 Kitti 数据集上 fine-tune 的启发，发现利用稀疏的标签也可以很好地对模型进行训练。文章利用传统算法如 AD-CENSUS 或 SGM 生成 label 来作为 groundtruth， 同时利用 CCCN（一种 confidence measure 的方法）来选取可信度高的 label，只利用这部分置信度高的 sparse label 来 fine-tune。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://zhuanlan.zhihu.com/p/31065813" target="_blank" rel="noopener">本期最新 9 篇论文，每一篇都想推荐给你 | PaperDaily #14</a></p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 深度信息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记：Pyramid Stereo Matching Network</title>
      <link href="/2018/10/18/PSM_Net.html"/>
      <url>/2018/10/18/PSM_Net.html</url>
      <content type="html"><![CDATA[<p>[//]<br>写在前面：此文发于CVPR2018，并公布了<a href="https://github.com/JiaRenChang/PSMNet" target="_blank" rel="noopener">代码</a></p><p>题目：Pyramid Stereo Matching Network<br>作者：Jia-Ren Chang, Yong-Sheng Chen<br>Department of Computer Science, National Chiao Tung University, Taiwan</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h4><p>立体匹配通用难点：occlusion areas,repeated patterns,textureless regions,reflective surfaces.<br>本文主攻方向：单独使用intensity-consistency导致在纹理区域表现不佳，现有立体匹配框架多基于patch-based Siamese结构且缺少context信息。<br>从全局context信息中提取regional support.</p><h4 id="other-works"><a href="#other-works" class="headerlink" title="other works"></a>other works</h4><ul><li>MC-CNN</li><li>Displets: utilizes object information by modeling 3D vehicles to resolve ambiguities in stereo matching.</li><li>ResMatchNet: learns to measure reflective confidence for the disparity maps to improve performance in ill-posed regions.</li><li>GC-Nets: employs the encoder-decoder architecture to merge multiscale features for cost volume regularization.</li></ul><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul><li>提出一个无后处理的end2end的立体匹配学习框架</li><li>引入pyramid pooling模块使提取的图像特征包含全局context信息</li><li>提出 堆栈沙漏式的3D-CNN ，去扩展cost volume时的局部的上下文信息</li><li>在KITTI刷到了state-of-the-art（目前被M2S_CSPN等挤下去了，在stereo2012/2015分别排名8/20 截止2018.10.18）</li></ul><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>提出PSM-Net，包括两个主要模块，spatital pyramid pooling 和3D-CNN.<br>spatial pyramind pooling 在不同尺度和位置聚合了全局context信息，并形成cost volume<br>3D-CNN使用stacked mutiple hourglass结构(来源：<a href="http://www-personal.umich.edu/~alnewell/pose/" target="_blank" rel="noopener">Stacked Hourglass Networks for Human Pose Estimation,ECCV2016</a>)标准化cost volume并链接中间的监督。</p><h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><div align="center"><p><img src="/2018/10/18/PSM_Net/network.png" alt="network12"><br><img src="/2018/10/18/PSM_Net/feature_extraction.png" alt="feature_extraction"><br><img src="/2018/10/18/PSM_Net/stacked_hourglass.png" alt="stacked_hourglass"></p></div><h4 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h4><p>本文主要借鉴了两种提取全局上下文信息的网络结构：<a href="https://arxiv.org/abs/1603.06937" target="_blank" rel="noopener">hourglass</a> 和 <a href="https://arxiv.org/abs/1406.4729" target="_blank" rel="noopener">pyramid pooling</a>.两种结构均有大量相关的工作。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://arxiv.org/abs/1803.08669" target="_blank" rel="noopener">Pyramid Stereo Matching Network</a></p>]]></content>
      
      <categories>
          
          <category> 文章阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 深度信息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>The volume boot has only 5.1MB disk space remaining</title>
      <link href="/2018/08/16/boot-space.html"/>
      <url>/2018/08/16/boot-space.html</url>
      <content type="html"><![CDATA[<p>/boot 目录中是系统引导文件和内核，更新内核之后旧内核还存放在里面，安装软件的时候就会提示 /boot 空间不足，佳解的决办法就是将旧内核删除。</p><p>1、查看磁盘使用情况</p><p>df -h</p><p><img src="https://upload-images.jianshu.io/upload_images/10342473-72be33f42c99fd30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="df-h"></p><a id="more"></a><p>2、查看正在使用的内核版本</p><p>uname -a<br>uname -r<br>都可以</p><p><img src="https://upload-images.jianshu.io/upload_images/10342473-166eb6d61884e489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot from 2018-08-16 10-02-08.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/10342473-8541c9d02f4d2fa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot from 2018-08-16 10-24-54.png"></p><p>3、查看系统中存在的内核版本</p><p>dpkg –get-selections | grep linux<br>（当出现deibstall,则说明已经删除）<br><img src="https://upload-images.jianshu.io/upload_images/10342473-0753709913b6887c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot from 2018-08-16 10-22-24.png"></p><p>4、把低于当前版本的内核删掉</p><p>sudo apt-get remove linux-image-4.13..0-41-generic<br>sudo apt-get autoremove linux-image-4.13..0-41-generic<br>都可以，至于autoremove 和remove的区别，我先用remove再用autoremove实验了一下，发现remove只能删除指定的image，而autoremove则可以把这个内核相关的“linux-headers-4.xx.x-xx”等东西删掉，删的更加彻底。</p><p><img src="https://upload-images.jianshu.io/upload_images/10342473-62b5dacc8d3474c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot from 2018-08-16 10-11-00.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/10342473-a6ed667a9d07717b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot from 2018-08-16 10-30-02.png"></p><p>5、删完之后df -h<br><img src="https://upload-images.jianshu.io/upload_images/10342473-6781a1c8351bed25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot from 2018-08-16 10-32-10.png"></p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XJBX </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则项之L0L1L2</title>
      <link href="/2018/08/03/l0l1l2re.html"/>
      <url>/2018/08/03/l0l1l2re.html</url>
      <content type="html"><![CDATA[<p><strong>注意，本文讨论的是L0L1L2范数作为<a href="https://blog.csdn.net/heyongluoyao8/article/details/52462400" target="_blank" rel="noopener">代价函数/损失函数/目标函数/期望风险</a>中<a href="http://www.datalearner.com/blog/1051509805091522" target="_blank" rel="noopener">正则项/结构风险</a>的应用，而不是作为经验风险项的应用。</strong></p><p>在经验风险中，<strong>L1(MAE)L2(MSE)</strong>两者常被用来约束数据的逻辑回归。虽然同样用于逻辑回归，但终归是有区别滴(存在即合理嘛)，两者之间的<a href="http://baijiahao.baidu.com/s?id=1603857666277651546&wfr=spider&for=pc" target="_blank" rel="noopener">不同</a>可以总结为<strong>MSE计算方便利于模型的学习，MAE对异常点具有更高的鲁棒性但在损失较小时仍有较大梯度，求解效率低。</strong></p><p>下面详细介绍L0L1L2范数以及它们作为正则项的应用。</p><a id="more"></a><p>一般正则项是以下公式的形式：</p><p>$$<br>\sum_{n=1}^{N}<br>\left.<br>\middle|<br>t_n-\bf w^T \phi(\bf x_n)<br>\middle|<br>\right.^k<br>+\lambda<br>\sum_{j=1}^M<br>\left.<br>\middle|<br>w_j<br>\middle|<br>\right.^q<br>$$</p><h3 id="L0范数"><a href="#L0范数" class="headerlink" title="L0范数"></a>L0范数</h3><p>L0范数是指向量中非0的元素的个数。</p><p>使用L0范数的意义在于希望向量Ｗ中的大部分元素都是0，即<strong>让W是稀疏的</strong>。(关于稀疏的概念可以看<a href="此处链接稀疏编码">稀疏编码－Sparse coding</a>)</p><p>需要注意的是：<br>1.L0很难优化求解(NP难问题)<br>2.虽然“稀疏性”的最直接测度标准是 “L0” 范式，但这是不可微的，而且通常很难进行优化，所以普遍做法是采用L0的最优凸近似L1范数来替代L0。</p><p>所以我们才有了L1范数～</p><h3 id="L1范数"><a href="#L1范数" class="headerlink" title="L1范数"></a>L1范数</h3><p>L1范数是指向量中各个元素的绝对值之和,又称曼哈顿距离，马氏距离（Manhattan distance）。</p><p>L1正则算子可以实现稀疏，因此又被称为“稀疏规则算子”。而在应用中，也多采用L1正则项实现模型的稀疏性。那么问题来了，L0正则算子具有明显的稀疏约束，而为什么要使用L1正则算子却不用L0呢？</p><p>主要原因有两个，一是L1可以确实实现稀疏约束，二是L0不可导难以优化求解。</p><p>关于L1为什么能够实现稀疏，简单解释是因为<strong>任何的规则化算子，如果它在Wi=0的地方不可微，并且可以分解为一个“求和”的形式，那么这个规则化算子就可以实现稀疏。</strong>，直观一点讲的话，<strong>L1范数更加倾向于选择一些数目较少的较大的值(换句话讲选择较多的零)。</strong>而从优化/先验知识/数值计算的角度更为详细地去理解L1的稀疏性，请移步<a href="https://www.cnblogs.com/hellcat/p/7979711.html#_label0" target="_blank" rel="noopener">『科学计算』L0、L1与L2范数理解</a>。</p><div align="center"><img src="/2018/08/03/l0l1l2re/laplace_distribution.png" width="50%" alt="数值计算角度解释L1范数的稀疏性"></div><p>这里插一句，如果数据集中某些特征值很大，而经验风险使用L1的话，L1倾向于选择更大的特征，这些特征会掩盖其他特征间的邻近关系。</p><h3 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h3><p>L2范数是指向量中各元素的平方和然后开根号。在回归中，被称作“岭回归”(Ridge Regression)，也叫“权值衰减”(Weight Decay)，可以理解为欧几里得距离(Euclid distance)。</p><p>在正则项中，<strong>L2范数的作用主要是用于防止数据过拟合，提升模型的泛化能力，同时改善ill-posed问题。</strong></p><!--由于采用了欧式距离的定义，所以--><p>L2为什么会防止过拟合？<br>L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，W中会出现许多接近0但不是0的元素(如果是0就变成L1了)，这些特征都会接近于0，这些小的权重参量会削弱数据中某些特征值较大的数据的作用，使得模型的泛化性能更好。。</p><p>对于改善ill-posed的问题，从优化或者数值计算的角度来说，L2范数有助于处理 condition number不好的情况下矩阵求逆很困难的问题。</p><p>为什么L2会改善ill-posed的问题呢？<br>简单地说一下，系统的解析解可以表示为：<br>$$\hat w = \left(X^TX\right)^{-1}X^T\rm y $$<br>当系统是ill-conditioned时，样本数量小于样本的维度，从解方程的角度说方程个数小于未知量个数，矩阵$X^TX$是奇异矩阵，即$X^TX$不可逆，所以$w$是不可求的。L2正则在此处就大显神威了，加上L2正则项之后，解变成了：<br>$$\hat w = \left(X^TX-\lambda I\right)^{-1} X^T\rm y$$</p><p>上面这个式子是可以求逆的，并且$\lambda$的引入会改善condition number，从而改善了ill-posed的问题，与此同时，求解的收敛速度也增加了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://blog.csdn.net/zchang81/article/details/70208061" target="_blank" rel="noopener">深度学习——L0、L1及L2范数</a><br>[2] <a href="https://blog.csdn.net/qingyang666/article/details/61919381" target="_blank" rel="noopener">曼哈顿距离，欧式距离，余弦距离</a><br><span id="[3]"> [3] <a href="https://blog.csdn.net/zouxy09/article/details/24971995" target="_blank" rel="noopener">机器学习中的范数规则化之（一）L0、L1与L2范数</a></span><br>[4] <a href="https://my.oschina.net/hunglish/blog/787596#h2_11" target="_blank" rel="noopener">机器学习——几种距离度量方法比较</a><br>[5] <a href="http://www.datalearner.com/blog/1051509805091522" target="_blank" rel="noopener">正则项的理解之正则从哪里来</a><br>[6] <a href="https://charlesliuyx.github.io/2017/10/03/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E5%8C%96/" target="_blank" rel="noopener">【直观详解】什么是正则化</a><br>[7] <a href="http://baijiahao.baidu.com/s?id=1603857666277651546&wfr=spider&for=pc" target="_blank" rel="noopener">机器学习大牛最常用的5个回归损失函数，你知道几个？</a></p>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XJBX </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>install</title>
      <link href="/2018/08/01/install.html"/>
      <url>/2018/08/01/install.html</url>
      <content type="html"><![CDATA[<h2 id="install-MATLAB"><a href="#install-MATLAB" class="headerlink" title="install MATLAB"></a>install MATLAB</h2><h3 id="Uninstall-MATLAB"><a href="#Uninstall-MATLAB" class="headerlink" title="Uninstall MATLAB"></a>Uninstall MATLAB</h3><p>main reference:<br><a href="https://ww2.mathworks.cn/help/install/ug/install-and-activate-without-an-internet-connection.html" target="_blank" rel="noopener">https://ww2.mathworks.cn/help/install/ug/install-and-activate-without-an-internet-connection.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matlabroot/bin/deactivate_matlab.sh</span><br></pre></td></tr></table></figure><p><code>matlabroot</code>represents your own MATLAB ROOT FILE FOLDER.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf matlabroot</span><br><span class="line">rm -r /home/username/.matlab</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ./.bashrc</span><br><span class="line">//delete the imformation about matlab</span><br></pre></td></tr></table></figure><h3 id="Install-MATLAB"><a href="#Install-MATLAB" class="headerlink" title="Install MATLAB"></a>Install MATLAB</h3><p>main reference:<br><a href="https://blog.csdn.net/qq_16234613/article/details/78996565" target="_blank" rel="noopener">https://blog.csdn.net/qq_16234613/article/details/78996565</a><br><a href="https://blog.csdn.net/u011961856/article/details/79644342" target="_blank" rel="noopener">https://blog.csdn.net/u011961856/article/details/79644342</a><br><a href="https://blog.csdn.net/yusiguyuan/article/details/24269129" target="_blank" rel="noopener">https://blog.csdn.net/yusiguyuan/article/details/24269129</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /media/matlab</span><br><span class="line">//mount -t 类型 -o 挂接方式 源路径 目标路径</span><br><span class="line">sudo mount -t auto -o loop /home/username/Downloads/R2018a_glnxa64_dvd1.iso /media/matlab</span><br><span class="line">cd..</span><br><span class="line">sudo /media/matlab/install</span><br><span class="line"></span><br><span class="line">umount /media/matlab</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ./.bashrc</span><br><span class="line">export PATH=$PATH:/usr/local/MATLAB/R2018/bin</span><br></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1]<br>[2]<br>[3]<br>[4] </p><hr><h2 id="install-latex-sublime"><a href="#install-latex-sublime" class="headerlink" title="install  latex+sublime"></a>install  latex+sublime</h2><h3 id="install-texlive"><a href="#install-texlive" class="headerlink" title="install texlive"></a>install texlive</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install texlive</span><br></pre></td></tr></table></figure><h3 id="install-sublime-text"><a href="#install-sublime-text" class="headerlink" title="install sublime-text"></a>install sublime-text</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</span><br><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line">echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text</span><br><span class="line"></span><br><span class="line">%% apt-get install latexmk</span><br></pre></td></tr></table></figure><h3 id="install-Package-control"><a href="#install-Package-control" class="headerlink" title="install Package-control"></a>install Package-control</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; </span><br><span class="line">h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; </span><br><span class="line">pf = &apos;Package Control.sublime-package&apos;; </span><br><span class="line">ipp = sublime.installed_packages_path(); </span><br><span class="line">urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) );</span><br><span class="line">by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); </span><br><span class="line">dh = hashlib.sha256(by).hexdigest(); </span><br><span class="line">print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure><h3 id="install-dbus"><a href="#install-dbus" class="headerlink" title="install dbus"></a>install dbus</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~/下载</span><br><span class="line">tar xzvf dbus-python-1.2.4.tar.gz</span><br><span class="line">sudo apt-get install libdbus-glib-1-dev</span><br><span class="line">cd dbus-python-1.2.4</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="Ubuntu安装Sublime-Text-3–解决无法使用搜狗中文输入法"><a href="#Ubuntu安装Sublime-Text-3–解决无法使用搜狗中文输入法" class="headerlink" title="Ubuntu安装Sublime Text 3–解决无法使用搜狗中文输入法"></a>Ubuntu安装Sublime Text 3–解决无法使用搜狗中文输入法</h3><p>安装完成后发现无法在Sublime输入中文，而linux常用输入法是搜狗For Linux输入法<br>解决方法:</p><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>保存下面的代码到文件 sublime_imfix.c ,<br>命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~ &amp;&amp; gedit sublime_imfix.c</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;gtk/gtkimcontext.h&gt;</span><br><span class="line">void gtk_im_context_set_client_window (GtkIMContext *context,</span><br><span class="line">         GdkWindow    *window)</span><br><span class="line">&#123;</span><br><span class="line"> GtkIMContextClass *klass;</span><br><span class="line"> g_return_if_fail (GTK_IS_IM_CONTEXT (context));</span><br><span class="line"> klass = GTK_IM_CONTEXT_GET_CLASS (context);</span><br><span class="line"> if (klass-&gt;set_client_window)</span><br><span class="line">   klass-&gt;set_client_window (context, window);</span><br><span class="line"> g_object_set_data(G_OBJECT(context),&quot;window&quot;,window);</span><br><span class="line"> if(!GDK_IS_WINDOW (window))</span><br><span class="line">   return;</span><br><span class="line"> int width = gdk_window_get_width(window);</span><br><span class="line"> int height = gdk_window_get_height(window);</span><br><span class="line"> if(width != 0 &amp;&amp; height !=0)</span><br><span class="line">   gtk_im_context_focus_in(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝保存即可～</p><h4 id="编译为共享库"><a href="#编译为共享库" class="headerlink" title="编译为共享库"></a>编译为共享库</h4><p>将上一步的代码编译成共享库 libsulime-imfix.so ，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">gcc -shared -o libsublime-imfix.so sublime_imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC</span><br></pre></td></tr></table></figure><p>有些童鞋无法编译，出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No package &apos;gtk+-2.0&apos; found</span><br><span class="line">sublime_imfix.c:1:30: fatal error: gtk/gtkimcontext.h: 没有那个文件或目录</span><br><span class="line"> #include &lt;gtk/gtkimcontext.h&gt;</span><br></pre></td></tr></table></figure><p>需要先安装必要的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libgtk2.0-dev</span><br></pre></td></tr></table></figure><p>安装完成后重新编译，可以了吧～</p><h4 id="修改sublime文件"><a href="#修改sublime文件" class="headerlink" title="修改sublime文件"></a>修改sublime文件</h4><p>然后将 libsublime-imfix.so 拷贝到 sublime_text 所在文件夹，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">sudo mv libsublime-imfix.so /opt/sublime_text/</span><br></pre></td></tr></table></figure><p>修改Sublime的命令 /usr/bin/subl 的内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /usr/bin/subl</span><br></pre></td></tr></table></figure><p>将文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">exec /opt/sublime_text/sublime_text &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>替换修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text &quot;$@&quot;</span><br></pre></td></tr></table></figure><p><strong>完成后，在命令行中执行 subl 重启Sublime ，就可以使用搜狗For Linux的中文输入法了～</strong></p><h4 id="保证多种启动方式均可使用搜狗"><a href="#保证多种启动方式均可使用搜狗" class="headerlink" title="保证多种启动方式均可使用搜狗"></a>保证多种启动方式均可使用搜狗</h4><p>继续图形界面快捷方式 sublime_text.desktop 的修改：</p><p>sudo gedit /usr/share/applications/sublime_text.desktop</p><p>将[Desktop Entry]字段下的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=/opt/sublime_text/sublime_text %F</span><br></pre></td></tr></table></figure><p>替换修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=bash -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text %F&quot;</span><br></pre></td></tr></table></figure><p>将[Desktop Action Window]字段下的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=/opt/sublime_text/sublime_text -n</span><br></pre></td></tr></table></figure><p>替换修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=bash -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text -n&quot;</span><br></pre></td></tr></table></figure><p>将[Desktop Action Document]字段下的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=/opt/sublime_text/sublime_text --command new_file</span><br></pre></td></tr></table></figure><p>替换修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=bash -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text --command new_file&quot;</span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.qingzz.cn/ubuntu_sublime_sogou" target="_blank" rel="noopener">http://www.qingzz.cn/ubuntu_sublime_sogou</a></p><h2 id="Install-Code-Blocks"><a href="#Install-Code-Blocks" class="headerlink" title="Install Code::Blocks"></a>Install Code::Blocks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:damien-moore/codeblocks-stable</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install codeblocks codeblocks-contrib</span><br></pre></td></tr></table></figure><p><a href="ttps://www.linuxidc.com/Linux/2017-10/148159.htm" target="_blank" rel="noopener">如何在Ubuntu 16.04/17.04上安装Code::Blocks</a><br><a href="https://blog.csdn.net/skullsky/article/details/53134114" target="_blank" rel="noopener">https://blog.csdn.net/skullsky/article/details/53134114</a></p><h3 id="参考资料：-1"><a href="#参考资料：-1" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1] </p><h2 id="Install-CUDA"><a href="#Install-CUDA" class="headerlink" title="Install CUDA"></a>Install CUDA</h2>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sublime</title>
      <link href="/2018/07/24/sublime.html"/>
      <url>/2018/07/24/sublime.html</url>
      <content type="html"><![CDATA[<h3 id="快速查找与替换"><a href="#快速查找与替换" class="headerlink" title="快速查找与替换"></a>快速查找与替换</h3><p>多数情况下，我们需要查找文中某个关键字出现的其它位置，这时并不需要重新将该关键字重新输入一遍然后搜索，我们只需要使用Shift + ←/→或Ctrl + D选中关键字，然后F3跳到其下一个出现位置，Shift + F3跳到其上一个出现位置，此外还可以用Alt + F3选中其出现的所有位置（之后可以进行多重编辑，也就是快速替换）。</p><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><p>转换为大写：Ctrl+KU<br>转换为小写：Ctrl+KL</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>[1] <a href="https://www.learnopencv.com/homography-examples-using-opencv-python-c/" target="_blank" rel="noopener">https://www.learnopencv.com/homography-examples-using-opencv-python-c/</a><br>[2] <a href="https://blog.csdn.net/xuyangcao123/article/details/70916767" target="_blank" rel="noopener">https://blog.csdn.net/xuyangcao123/article/details/70916767</a><br>[3] <a href="https://www.zybuluo.com/codeep/note/163962" target="_blank" rel="noopener">https://www.zybuluo.com/codeep/note/163962</a><br>[4] <a href="http://blog.sina.com.cn/s/blog_6965d96d0101u98s.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6965d96d0101u98s.html</a></p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摸鱼日志 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单应性变换</title>
      <link href="/2018/07/23/homography.html"/>
      <url>/2018/07/23/homography.html</url>
      <content type="html"><![CDATA[<h3 id="单应性变换-homography"><a href="#单应性变换-homography" class="headerlink" title="单应性变换(homography)"></a>单应性变换(homography)</h3><p>所谓单应性变换就是一个平面到另一个平面的映射关系。</p><div align="center"><img src="/2018/07/23/homography/homography-example-768x511.jpg" width="300" alt="单应性矩阵"></div><a id="more"></a><p>如图，两张图片中的相同的点叫做corresponding points,比如图中红色的两点就是一对corresponding points。单应性(homography)矩阵就是表示从一张图到另一张图的映射关系的变换矩阵。</p><p>$$<br>H=\begin{bmatrix}<br>h_{00} &amp; h_{01} &amp; h_{02} \<br>h_{10} &amp; h_{11} &amp; h_{12} \<br>h_{20} &amp; h_{21} &amp; h_{22}<br>\end{bmatrix}<br>$$</p><p>$$ \begin{bmatrix}<br>x_1 \\ y_1 \\ 1\end{bmatrix}=H\begin{bmatrix}x_2\\ y_2\\ 1\end{bmatrix}=<br>\begin{bmatrix}<br>h_{00} &amp; h_{01} &amp; h_{02}\<br>h_{10} &amp; h_{11} &amp; h_{12}\<br>h_{20} &amp; h_{21} &amp; h_{22}<br>\end{bmatrix}<br>\begin{bmatrix}<br>x_2\<br>y_2\<br>1\end{bmatrix}<br>$$</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Read source image.</span></span><br><span class="line">    im_src = cv2.imread(<span class="string">'book2.jpg'</span>)</span><br><span class="line">    <span class="comment"># Four corners of the book in source image</span></span><br><span class="line">    pts_src = np.array([[<span class="number">141</span>, <span class="number">131</span>], [<span class="number">480</span>, <span class="number">159</span>], [<span class="number">493</span>, <span class="number">630</span>],[<span class="number">64</span>, <span class="number">601</span>]])</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Read destination image.</span></span><br><span class="line">    im_dst = cv2.imread(<span class="string">'book1.jpg'</span>)</span><br><span class="line">    <span class="comment"># Four corners of the book in destination image.</span></span><br><span class="line">    pts_dst = np.array([[<span class="number">318</span>, <span class="number">256</span>],[<span class="number">534</span>, <span class="number">372</span>],[<span class="number">316</span>, <span class="number">670</span>],[<span class="number">73</span>, <span class="number">473</span>]])</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Calculate Homography</span></span><br><span class="line">    h, status = cv2.findHomography(pts_src, pts_dst)</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># Warp source image to destination based on homography</span></span><br><span class="line">    im_out = cv2.warpPerspective(im_src, h, (im_dst.shape[<span class="number">1</span>],im_dst.shape[<span class="number">0</span>]))</span><br><span class="line">     </span><br><span class="line">    <span class="comment"># Display images</span></span><br><span class="line">    cv2.imshow(<span class="string">"Source Image"</span>, im_src)</span><br><span class="line">    cv2.imshow(<span class="string">"Destination Image"</span>, im_dst)</span><br><span class="line">    cv2.imshow(<span class="string">"Warped Source Image"</span>, im_out)</span><br><span class="line"> </span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="单应性变换应用"><a href="#单应性变换应用" class="headerlink" title="单应性变换应用"></a>单应性变换应用</h3><p>最常见的当属于对文档进行自由变换。如使用手机拍摄文件或者明信片时，由于相机或拍摄角度等因素影响，拍摄的文档并不是矩形，而往往带有一定程度的畸变，此时可以使用单应性变换对文档进行自由变换矫正。此处从<a href="http://blog.sina.com.cn/s/blog_6965d96d0101u98s.html" target="_blank" rel="noopener">网上</a>扒了一个使用PS对名片进行自由变换的例子，其本质就是单应性变换的应用。</p><p>拍摄照片：</p><div align="center"><img src="/2018/07/23/homography/homo1.jpeg" width="50%" alt="拍摄名片"></div><p>PS自由变换后：</p><div align="center"><img src="/2018/07/23/homography/homo2.jpeg" width="50%" alt="变换后名片"></div><p>另一个例子：</p><div align="center"><img src="/2018/07/23/homography/homo3.jpg" width="30%" alt="Les Horribles Cernettes"><img src="/2018/07/23/homography/homo4.jpg" width="50%" alt="被插入图像"><img src="/2018/07/23/homography/homo5.jpg" width="50%" alt="插入后图像"></div><p>中间时代广场左上角的广告牌被替换为”Les Horribles Cernettes”的海报。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://www.learnopencv.com/homography-examples-using-opencv-python-c/" target="_blank" rel="noopener">https://www.learnopencv.com/homography-examples-using-opencv-python-c/</a><br>[2] <a href="https://blog.csdn.net/xuyangcao123/article/details/70916767" target="_blank" rel="noopener">https://blog.csdn.net/xuyangcao123/article/details/70916767</a><br>[3] <a href="https://www.zybuluo.com/codeep/note/163962" target="_blank" rel="noopener">markdown公式指导手册</a><br>[4] <a href="http://blog.sina.com.cn/s/blog_6965d96d0101u98s.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6965d96d0101u98s.html</a></p>]]></content>
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> XJBX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记：Enhancing the Spatial Resolution of Stereo Images using Parallax Prior</title>
      <link href="/2018/07/22/Enhancing_the_Spatial_Resolution_of_Stereo_Images_using_Parallax_Prior.html"/>
      <url>/2018/07/22/Enhancing_the_Spatial_Resolution_of_Stereo_Images_using_Parallax_Prior.html</url>
      <content type="html"><![CDATA[<p>### </p><p>论文要解决的问题是图像空间超分辨，主要的想法是通过双目视觉的视差先验实现图像的亚像素精度空间超分辨。</p><p>文章整体的思路比较清晰，首先将RGB转换到$Yc_bc_r$空间，以分别处理亮度(luminance)和色度(chrominance),。网络由两个子网络组成，第一个网络处理Y通道，得到高分辨率的Y通道图像，第二个处理$C_b$和$C_r$通道，得到高分辨率的彩色图像。</p><div align="center"><img src="/2018/07/22/Enhancing_the_Spatial_Resolution_of_Stereo_Images_using_Parallax_Prior/upload_image/Stereo_SR_Kim1.png" alt="网络结构"></div><p>问题：</p><p>1.视差先验(parallax prior)是怎么体现的？<br>2.在文章结果部分有和VDSR对比的实验结果，但VDSR是SISR，此处使用stereo的两张图像，这么比公平吗？<br>3.Psycho的stereo方法甚至不如VDSR，这。。。。<br>4.在处理第一个网络的输入时，是把right image进行pixel shift，平移n个pixel，但是每个点对应的偏移量是不一样的，这里怎么处理、</p>]]></content>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
            <tag> 深度信息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文笔记：乱七八糟集合</title>
      <link href="/2018/06/23/paperreading_luanqibazao.html"/>
      <url>/2018/06/23/paperreading_luanqibazao.html</url>
      <content type="html"><![CDATA[<h3 id="Enhancing-the-Spatial-Resolution-of-Stereo-Images-using-Parallax-Prior"><a href="#Enhancing-the-Spatial-Resolution-of-Stereo-Images-using-Parallax-Prior" class="headerlink" title="Enhancing the Spatial Resolution of Stereo Images using Parallax Prior"></a>Enhancing the Spatial Resolution of Stereo Images using Parallax Prior</h3><p>这篇论文的main idea 是使用DPN网络和STN网络结合，针对RGB+NIR融合过程出现匹配不准确的现象提出一种多模态融合方案。</p><h3 id="STN"><a href="#STN" class="headerlink" title="STN"></a>STN</h3><p>首先看什么是STN网络。这里就不看原论文了，在CSDN上找了一些文章。</p><p>首先看STN的insight：<br>文章提出的STN的作用类似于传统的矫正的作用。比如人脸识别中，需要先对检测的图片进行关键点检测，然后使用关键点来进行对齐操作。但是这样的一个过程是需要额外进行处理的。[进行什么样的额外处理？]但是有了STN后，检测完的人脸，直接就可以做对齐操作。关键的一点就是这个矫正过程是可以进行梯度传导的。想象一下，人脸检测完了，直接使用ROI pooling取出人脸的feature map，输入STN就可以进行矫正，输出矫正后的人脸。后面还可以再接点卷积操作，直接就可以进行分类，人脸识别的训练。整个流程从理论上来说，都有梯度传导，理论上可以将检测+对齐+识别使用一个网络实现。当然实际操作中可能会有各种trick。</p><p>STN网络由Localisation Network ，Grid generator，Sampler，3个部分组成。<br>Localisation Network：<br>该网络就是一个简单的回归网络。将输入的图片进行几个卷积操作，然后全连接回归出6个角度值（假设是仿射变换），2*3的矩阵。【为什么是6个角度？】</p><p>Grid generator：<br>网格生成器负责将V中的坐标位置，通过矩阵运算，计算出目标图V中的每个位置对应原图U中的坐标位置。即生成T(G)。</p><p>这里的Grid采样过程，对于二维仿射变换（旋转，平移，缩放）来说，就是简单的矩阵运算。<br>上式中，s代表原始图的坐标，t代表目标图的坐标。A为Localisation Network网络回归出的6个角度值。</p><p>整个Grid生成过程就是，首先你需要想象上图中V-FeatureMap中全是白色或者全是黑色，是没有像素信息的。也就是说V-FeatureMap还不存在，有的只是V-FeatureMap的坐标位置信息。然后将目标图V-FeatureMap中的比如（0，0）（0，1）……位置的坐标，与2*3变换矩阵运算。就会生成出在原始图中对应的坐标信息，比如（5，0）（5，1）……。这样所有的目标图的坐标都经过这样的运算就会将每个坐标都产生一个与之对应的原图的坐标，即T(G)。然后通过T(G)和原始图U-FeatureMap的像素，将原始图中的像素复制到V-FeatureMap中，从而生成目标图的像素。<br>【这步操作有点骚，为什么不生成从U到V的放射变换矩阵？】</p><p>Sampler的存在使得STN可微。</p><p>STN网络是一个CONV还是FC<br>这个网络会有几个隐层，这些隐层可以是全连接层，也可以是卷积层。<br>也就是说，STN是一种流程思想。</p><p>这里没看明白。但后一层，需要做回归，因为要输出变换参数的值。</p><p>参考资料<br>[1]<a href="https://blog.csdn.net/qq_39422642/article/details/78870629，此博客中的连接很有用。" target="_blank" rel="noopener">https://blog.csdn.net/qq_39422642/article/details/78870629，此博客中的连接很有用。</a><br><a href="https://blog.csdn.net/qq_14845119/article/details/79510714" target="_blank" rel="noopener">https://blog.csdn.net/qq_14845119/article/details/79510714</a></p><h3 id="DPN"><a href="#DPN" class="headerlink" title="DPN"></a>DPN</h3><p>Baseline LR中的backward warp很有意思。有点STN中反step3的影子。</p><p>发现自己的一个概念一直用错了。右图的视差dr，应用到左图，可以重建出右图。</p><p>原文中说，输出四个不同尺度（disp4~disp1）的视差图，它们前者是后者的两倍。尽管只有单张输入图片，该网络能够输出不同尺度上的两个视差图——left-to-right 和 right-to-left。</p><p>上面这张图是博客作者自己画的？反正没找到论文作者的版本。<br>网络输出两个视差图是毋庸置疑的，文章material awareness中示意图也说明了这点。<br>为什么能够输出两个视差图呢？</p><p>参考资料：<br>这一篇是DPN的一个baseline LR <a href="http://yyliu.cn/post/750ec7f0.html" target="_blank" rel="noopener">http://yyliu.cn/post/750ec7f0.html</a><br>下面两篇是翻译：<br><a href="http://www.yyliu.cn/post/c68cf6db.html" target="_blank" rel="noopener">http://www.yyliu.cn/post/c68cf6db.html</a><br><a href="https://zhuanlan.zhihu.com/p/29528596" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29528596</a><br>这篇是概括性解读+code<br><a href="https://blog.csdn.net/lvhao92/article/details/76586101" target="_blank" rel="noopener">https://blog.csdn.net/lvhao92/article/details/76586101</a></p><h3 id="Deep-Material-aware-Cross-spectral-Stereo-Matching"><a href="#Deep-Material-aware-Cross-spectral-Stereo-Matching" class="headerlink" title="Deep Material-aware Cross-spectral Stereo Matching"></a>Deep Material-aware Cross-spectral Stereo Matching</h3><p>Introduction</p><ul><li>混合相机系统的align，如果使用Beam filter,会有长时间曝光造成blur.而使用stereo合一在align的同时获得depth</li></ul><p>【相当于初始化depth用的是dpn单目方式】</p><ul><li><p>作者让DPN只学深度，使用了symmetric的结构方式STN学习几何信息。</p></li><li><p>作者采集了数据集，并且自己label 了material segment进行train STN。</p></li></ul><p>【看到这里作者的STN网络是不能借鉴了，猜测借鉴的部分还有wrap等】</p><p>Related Work</p><ul><li><p>已有的交叉模态立体匹配方案只考虑了feature和region没有考虑material awareness</p></li><li><p>已有的非监督深度估计方案只考虑了RGB而没有考虑光谱，还有非漫发射。</p></li></ul><p>【看到这里想到我们的方案是想让两路的图像尽可能接近</p><p>采用类DPN方案：可以得到disparity–&gt;align–&gt;enhance(这里enhance与求disp有冲突吗？没有。)求disp的时候可以算一个loss，这个loss主体是||L’-L||_2+||R’-R||_2；enhance的时候loss主体是？？？Enhance需要找1、jiangzhu的论文2、今年CVPR陈畅师兄介绍的zero-shot增强的论文。3、思考数据集怎么做？我们是没有label的。】</p><p>Simultaneous Disparity Estimation and Spectral Translation</p><ul><li><p>文字贼有意思，simultaneously to respectively learn disparity and spectral translation</p></li><li><p>看到他用STN把RGB合成pseudo NIR，我在考虑是否应该使用CNN来把spectral image转化为灰度图像。那么这里为什么不直接用光谱响应曲线呢？考虑如下：1、合成后的灰度图像并不很好。【其实两幅图像的拍摄角度不同，光线也不会一样，所以导致spectral image合成后的图像也并不会完全一样。但是这个差别是否可以忽略不计呢?】</p></li><li><p>reprojection error 重投影误差</p></li><li><p>出现了！出现了！使用STN进行transform(wrap)。。。吗【又看了一遍DPN后发现并不是，STN的作用：“在训练过程中，网络学习通过对相反的图片采样来生成图片。我们的成像模型，采用来自空间变形网络（spatial transformer network，STN），通过视差图对输入图像取样。STN采用双线性采样，它的输出像素是四个输入像素的权重相加 。与其他方法相比，双线性采样局部完全可微，无缝集成到我们的全卷积网络架构。意味着不需要单纯化或近似我们的损失函数。”】</p></li></ul><h3 id="Spectral-Translation-Network"><a href="#Spectral-Translation-Network" class="headerlink" title="Spectral Translation Network"></a>Spectral Translation Network</h3><ul><li><p>包括局部滤波，白平衡，曝光校正。</p></li><li><p>pseudo NIR 由RB白平衡G(\theta)和像素值F(\theta)加权得到。</p><ul><li>F(\theta)的权值由Filter Generating Network FGN学习得到。</li></ul></li><li><p>FGN的结构和DPN一样。此处为了不让STN学习到disp信息，所以使用了一个left-right symmetric filtering kernels(symmetric CNN)，即FGN。FGN可以平等地对待左右图的每一个像素并且不对输入产生shift【这里symmetric cnn是什么，为什么可以不学到disp信息？为啥对称了就学不到了？】【STN除了FGN以外还有什么组成】</p></li></ul><h3 id="Incorporating-Material-aware-Confidence-into-Disparity-Prediction-Network"><a href="#Incorporating-Material-aware-Confidence-into-Disparity-Prediction-Network" class="headerlink" title="Incorporating Material-aware Confidence into Disparity Prediction Network"></a>Incorporating Material-aware Confidence into Disparity Prediction Network</h3><ul><li><p>提出一个问题：material awareness和disp prediction没有结合</p></li><li><p>解决方法：把material-aware confidence加到DPN loss中去。</p></li><li><p>方案1：把确定区域的disp传播到不确定性区域，（利用确定的disp求不确定的disp），为此，作者提出了一个新的confidence-weighted smoothing technique</p></li><li><p>方案2：改写DPN LOSS，增加material-specific alignment and smoothness losses</p></li><li><p>方案1+方案2.Done！</p></li><li><p>smooth是一种预测未知区域disp的方法（这么讲好有道理）</p></li><li><p>方案1：简单来说就是对unreliable区域的disp进行类插值预测。</p></li><li><p>方案2：改造DPN loss貌似很复杂，不看了。</p></li><li><p>随后作者举例说明怎么使用方案1 2 </p><ul><li>作者介绍了数据集</li></ul></li></ul><p>Experiment Result</p><ul><li><p>使用了Deeplab net进行fine-tune，用于 material awareness</p></li><li><p>本文的对比对象是   CMA/ ANCC/ DASC /SIFT FLOW/</p></li><li><p>ablation study</p></li></ul><p>看到最后有个问题，本文中DPN的输入为什么会画成两个输入的形式？<br>并且输出为两个disp。这里的问题还是original 的DPN没有搞清楚。</p><hr><p>20180917再次阅读。</p><p>主要阅读method部分。追求技术细节。</p><p>首先，DPN的作用是求视差，这里没有问题。关于其约束，使用了重投影误差，查了一下重投影误差并没太仔细看，觉得这里可以先简单理解为左右一致性。其loss设置的比较复杂，但感觉基本就第一项在起作用。</p><p>考虑其训练过程和测试过程。</p>]]></content>
      
      
        <tags>
            
            <tag> 论文笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5分钟利用Github+Hexo搭建个人博客!</title>
      <link href="/2018/06/22/github+hexo.html"/>
      <url>/2018/06/22/github+hexo.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文记录了使用github+hexo搭建个人博客的过程以及搭建过程中遇到的一些问题。</p><p>关于使用hexo搭建博客，<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a>已经有了很详细的介绍，但官方文档的介绍往往是力求全面详尽而显得过于冗长(尽管hexo已经够简洁了)，下面介绍如何以最快的速度实现一个“最小hexo系统”。</p><p>搭建环境为Ubuntu16.04.(Windows/Mac/Linux等其他环境请参考<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a>)</p><a id="more"></a><hr><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ol><li><p>安装Git：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git-core</span><br></pre></td></tr></table></figure></li><li><p>hexo是基于Node.js的静态博客，需要使用node.js里的npm工具，所以接下来下载Node.js。以下两种方式二选一即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></li><li><p>下载完成后，重启终端并执行下列命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure></li></ol><p>至此，我们完成了安装hexo的准备工作。而安装hexo呢，只需一个命令：</p><ol start="4"><li>安装hexo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure></li></ol><p>hexo安装完毕！</p><hr><h3 id="发布你的第一篇文章"><a href="#发布你的第一篇文章" class="headerlink" title="发布你的第一篇文章"></a>发布你的第一篇文章</h3><ol><li><p>初始化hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo i blog //init的缩写 blog是项目名</span><br><span class="line">$ cd blog //切换到站点根目录</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo g //generetor的缩写</span><br><span class="line">$ hexo s //server的缩写</span><br></pre></td></tr></table></figure></li><li><p>创建第一篇文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new mypaper.md</span><br><span class="line">//文章会生成在/blog/sorce/_post/下</span><br></pre></td></tr></table></figure></li><li><p>本地服务器访问网页<br>打开浏览器输入<code>localhost:4000</code>查看网页效果，当然，此时只是默认主题，如果不喜欢可以使用<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a>，这是一个界面简洁且功能丰富的主题。</p></li><li><p>设置github仓库<br>在github上新建一个repository并且务必命名为<code>username.github.io</code>。修改本地blog根目录下的配置文件_config.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git@github.com:username/username.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li><li><p>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>将博客部署到github上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g //generate</span><br><span class="line">hexo d //deploy</span><br></pre></td></tr></table></figure></li></ol><h3 id="花里胡哨的东西"><a href="#花里胡哨的东西" class="headerlink" title="花里胡哨的东西"></a>花里胡哨的东西</h3><h5 id="首页只显示「摘要」"><a href="#首页只显示「摘要」" class="headerlink" title="首页只显示「摘要」"></a>首页只显示「摘要」</h5><p>在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供<a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95" target="_blank" rel="noopener">三种方式</a>来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法：</p><p>1.在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo 提供的方式 「推荐」<br>2.在文章的 front-matter 中添加 description，并提供文章摘录</p><p>3.自动形成摘要，在 主题配置文件 中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure><p>默认截取的长度为 150 字符，可以根据需要自行设定</p><p>建议使用 <code>&lt;!-- more --&gt;</code>（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。</p><p><strong>尝试了第一二种方式，但是第二种方式在超过一行的情况下不work，还没有找到解决方法。</strong></p><p>————20190618更新————</p><h5 id="页面点击小红心"><a href="#页面点击小红心" class="headerlink" title="页面点击小红心"></a>页面点击小红心</h5><p>将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。<br>love.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function(e,t,a)&#123;function r()&#123;for(var e=0;e&lt;n.length;e++)n[e].alpha&lt;=0?(t.body.removeChild(n[e].el),n.splice(e,1)):(n[e].y--,n[e].scale+=.004,n[e].alpha-=.013,n[e].el.style.cssText=&quot;left:&quot;+n[e].x+&quot;px;top:&quot;+n[e].y+&quot;px;opacity:&quot;+n[e].alpha+&quot;;transform:scale(&quot;+n[e].scale+&quot;,&quot;+n[e].scale+&quot;) rotate(45deg);background:&quot;+n[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;var n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;,function(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),function()&#123;var a=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;a&amp;&amp;a(),function(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,n.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;),t.body.appendChild(a)&#125;(e)&#125;&#125;(),r()&#125;(window,document);</span><br></pre></td></tr></table></figure><p>找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="背景的设置"><a href="#背景的设置" class="headerlink" title="背景的设置"></a>背景的设置</h5><p>将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;i=a.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,c=a.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function o()&#123;d.clearRect(0,0,i,c);var n,e,t,a,m,r,y=[x].concat(w);w.forEach(function(o)&#123;for(o.x+=o.xa,o.y+=o.ya,o.xa*=o.x&gt;i||o.x&lt;0?-1:1,o.ya*=o.y&gt;c||o.y&lt;0?-1:1,d.fillRect(o.x-.5,o.y-.5,1,1),e=0;e&lt;y.length;e++)n=y[e],o!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(a=o.x-n.x,m=o.y-n.y,r=a*a+m*m,r&lt;n.max&amp;&amp;(n===x&amp;&amp;r&gt;=n.max/2&amp;&amp;(o.x-=.03*a,o.y-=.03*m),t=(n.max-r)/n.max,d.beginPath(),d.lineWidth=t/2,d.strokeStyle=&quot;rgba(&quot;+u.c+&quot;,&quot;+(t+.2)+&quot;)&quot;,d.moveTo(o.x,o.y),d.lineTo(n.x,n.y),d.stroke()));y.splice(y.indexOf(o),1)&#125;),l(o)&#125;var i,c,a=document.createElement(&quot;canvas&quot;),u=function()&#123;var t=e(&quot;script&quot;),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,&quot;zIndex&quot;,-1),o:n(i,&quot;opacity&quot;,.5),c:n(i,&quot;color&quot;,&quot;0,0,0&quot;),n:n(i,&quot;count&quot;,99)&#125;&#125;(),m=&quot;c_n&quot;+u.l,d=a.getContext(&quot;2d&quot;),l=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,r=Math.random,x=&#123;x:null,y:null,max:2e4&#125;;a.id=m,a.style.cssText=&quot;position:fixed;top:0;left:0;z-index:&quot;+u.z+&quot;;opacity:&quot;+u.o,e(&quot;body&quot;)[0].appendChild(a),t(),window.onresize=t,window.onmousemove=function(n)&#123;n=n||window.event,x.x=n.clientX,x.y=n.clientY&#125;,window.onmouseout=function()&#123;x.x=null,x.y=null&#125;;for(var w=[],y=0;u.n&gt;y;y++)&#123;var s=r()*i,f=r()*c,h=2*r()-1,g=2*r()-1;w.push(&#123;x:s,y:f,xa:h,ya:g,max:6e3&#125;)&#125;setTimeout(function()&#123;o()&#125;,100)&#125;();</span><br></pre></td></tr></table></figure><p>找到 \themes\next\layout_layout.swing 文件， 在文件的后面，<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":"hijiki","bottom":-30,"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script>标签之前 添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 背景动画 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="给-Github-添加-README"><a href="#给-Github-添加-README" class="headerlink" title="给 Github 添加 README"></a>给 Github 添加 README</h5><p>默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。<br>正确的解决方法其实很简单：<br>方法1：<br>把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。<br>方法2：<br>解决方法很简单，在站点配置文件中，搜索 skip_render:，在其冒号后加一个空格然后加上 README.md 即可。</p><div style="display: none">##### 实现guestbook留言板功能进入到博客的根目录，运行命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page guestbook</span><br></pre></td></tr></table></figure></div>##### 添加Local search功能安装搜索插件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo-generator-searchdb</span><br></pre></td></tr></table></figure><p>在博客根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>配置博客<br>安装完成，编辑博客配置文件：_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>配置主题<br>Next 主题自带搜索设置，编辑主题配置文件：_config.yml</p><p>找到文件中 Local search 的相关配置，设为 true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>hexo 重新部署</p><h5 id="hexo本地图片插入"><a href="#hexo本地图片插入" class="headerlink" title="hexo本地图片插入"></a>hexo本地图片插入</h5><p>关于图片插入，耗费了我一些时间。最初我是在/source/文件夹下建立了一个upload_image/用来存放图片，在markdown中调用时是<code>![image](../../upload_image/image.png)</code>这种形式，可以看出，需要向上跳两级目录，才能找到对应的图像。<br>后来又尝试把图像直接放在与.md文件同一目录下，要不然是在编辑markdown时不显示，要不然是生成的静态网页不显示。<br>找了好久终于在<a href="http://www.xinxiaoyang.com/programming/2016-11-25-hexo-image-bug/" target="_blank" rel="noopener">Hexo 图片插入</a>找到了解决方法，需要安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>这样一个插件。方可以使用相对路径的图片，既可以在markdown中显示，也可以在网页中显示。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1] <a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">大道至简——Hexo简洁主题推荐</a><br>[2]<a href="https://neveryu.github.io/2016/09/30/hexo-next-two/#5-%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E5%B0%8F%E7%BA%A2%E5%BF%83%E7%9A%84%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">Hexo-NexT搭建个人博客（二）</a><br>[3]<a href="https://dingxuewen.com/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%E4%BA%8C/" target="_blank" rel="noopener">Hexo 搭建博客的个性化设置二</a><br>[4]<a href="https://blog.paddings.cn/2016/05/11/blog/hexo-guestbook/" target="_blank" rel="noopener">Hexo NexT 主题添加留言本页面</a><br>[5]<a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">hexo - Next 主题添加搜索功能</a></p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摸鱼日志 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用神经网络进行图像超分辨踩的坑</title>
      <link href="/2018/05/02/SubpixelTrick.html"/>
      <url>/2018/05/02/SubpixelTrick.html</url>
      <content type="html"><![CDATA[<p>1、matlab的bicubic结果会有小于0或者大于255的情况出现。</p><p>Image interpolation wrong for pixel values exceeding vmax #8631<br>MATLAB<code>resize</code>函数中也说明了：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%   For bicubic interpolation, the output image may have some values</span></span><br><span class="line"><span class="comment">%   slightly outside the range of pixel values in the input image.  This</span></span><br><span class="line"><span class="comment">%   may also occur for user-specified interpolation kernels.</span></span><br><span class="line"><span class="comment">%</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>2、神经网络训练出来的结果也会有小于0或者大于255的情况出现</p><p>Also remember that loss function is based on scaled images (pixel values between 0 and 1), so the predicted residual has to be scaled back by 255 before it is added to low resolution image. If some pixels become negative or go above 255, we return them to 0 and 255 respectively before saving.</p><p>解决方法：<br>*<em>make sure no pixels are outside [0, 255] interval<br>*</em></p><p>参考<br>1.<a href="https://www.cntk.ai/pythondocs/CNTK_302A_Evaluation_of_Pretrained_Super-resolution_Models.html" target="_blank" rel="noopener">https://www.cntk.ai/pythondocs/CNTK_302A_Evaluation_of_Pretrained_Super-resolution_Models.html</a><br>2.<a href="https://cntk.ai/pythondocs/CNTK_302B_Image_Super-resolution_Using_CNNs_and_GANs.html" target="_blank" rel="noopener">https://cntk.ai/pythondocs/CNTK_302B_Image_Super-resolution_Using_CNNs_and_GANs.html</a><br>3.<a href="https://blog.csdn.net/Autism_/article/details/79401798" target="_blank" rel="noopener">https://blog.csdn.net/Autism_/article/details/79401798</a><br>4.<a href="https://github.com/matplotlib/matplotlib/issues/8631" target="_blank" rel="noopener">https://github.com/matplotlib/matplotlib/issues/8631</a></p>]]></content>
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> XJBX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Life is short you need python</title>
      <link href="/2018/04/22/pythonTrick.html"/>
      <url>/2018/04/22/pythonTrick.html</url>
      <content type="html"><![CDATA[<h3 id="关于if-not-x-amp-if-x-is-not-None-amp-if-not-x-is-None"><a href="#关于if-not-x-amp-if-x-is-not-None-amp-if-not-x-is-None" class="headerlink" title="关于if not x:&amp;if x is not None&amp;if not x is None"></a>关于<code>if not x:</code>&amp;<code>if x is not None</code>&amp;<code>if not x is None</code></h3><p>代码中经常会有变量是否为None的判断，有三种主要的写法：</p><p> 第一种是<code>if x is None</code>；</p><p>第二种是 <code>if not x：</code>；</p><p>第三种是<code>if not x is None</code>（这句这样理解更清晰<code>if not (x is None)</code>） 。</p><p>如果你觉得这样写没啥区别，那么你可就要小心了，这里面有一个坑。先来看一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 1  </span><br><span class="line">&gt;&gt;&gt; not x  </span><br><span class="line">False  </span><br><span class="line">&gt;&gt;&gt; x = [1]  </span><br><span class="line">&gt;&gt;&gt; not x  </span><br><span class="line">False  </span><br><span class="line">&gt;&gt;&gt; x = 0  </span><br><span class="line">&gt;&gt;&gt; not x  </span><br><span class="line">True  </span><br><span class="line">&gt;&gt;&gt; x = [0]         # You don&apos;t want to fall in this one.  </span><br><span class="line">&gt;&gt;&gt; not x  </span><br><span class="line">False</span><br></pre></td></tr></table></figure><a id="more"></a><p>在python中 None,  False, 空字符串””, 0, 空列表[], 空字典{}, 空元组()都相当于False ，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not None == not False == not &apos;&apos; == not 0 == not [] == not &#123;&#125; == not ()</span><br></pre></td></tr></table></figure><p>因此在使用列表的时候，如果你想区分<code>x==[]</code>和<code>x==None</code>两种情况的话, 此时<code>if not x:</code>将会出现问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = []  </span><br><span class="line">&gt;&gt;&gt; y = None  </span><br><span class="line">&gt;&gt;&gt;   </span><br><span class="line">&gt;&gt;&gt; x is None  </span><br><span class="line">False  </span><br><span class="line">&gt;&gt;&gt; y is None  </span><br><span class="line">True  </span><br><span class="line">&gt;&gt;&gt;   </span><br><span class="line">&gt;&gt;&gt;   </span><br><span class="line">&gt;&gt;&gt; not x  </span><br><span class="line">True  </span><br><span class="line">&gt;&gt;&gt; not y  </span><br><span class="line">True  </span><br><span class="line">&gt;&gt;&gt;   </span><br><span class="line">&gt;&gt;&gt;   </span><br><span class="line">&gt;&gt;&gt; not x is None  </span><br><span class="line">&gt;&gt;&gt; True  </span><br><span class="line">&gt;&gt;&gt; not y is None  </span><br><span class="line">False  </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>也许你是想判断x是否为None，但是却把<code>x==[]</code>的情况也判断进来了，此种情况下将无法区分。<br>对于习惯于使用if not x这种写法的pythoner，必须清楚x等于None,  False, 空字符串””, 0, 空列表[], 空字典{}, 空元组()时对你的判断没有影响才行。 </p><p>而对于<code>if x is not None</code>和<code>if not x is None</code>写法，很明显前者更清晰，而后者有可能使读者误解为<code>if (not x) is None</code>，因此推荐前者，同时这也是谷歌推荐的风格</p><p>结论：</p><p><code>if x is not None</code>是最好的写法，清晰，不会出现错误，以后坚持使用这种写法。</p><p>使用if not x这种写法的前提是：必须清楚x等于None,  False, 空字符串””, 0, 空列表[], 空字典{}, 空元组()时对你的判断没有影响才行。</p><h3 id="Python-if-和-for-的多种写法"><a href="#Python-if-和-for-的多种写法" class="headerlink" title="Python if 和 for 的多种写法"></a>Python if 和 for 的多种写法</h3><p>1.not in</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a not in [2,3,4]</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a in [2,3,4] </span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>2.c if a else b   #这里注意，一定要有b,而且b不能为pass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=3 if 2&gt;3 else 4</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a=3 if 2&lt;3 else 4 </span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>3.[fun(a) for a in […]] </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [a+1 for a in [2,3,4,5,6]]</span><br><span class="line">[3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure><p>4.a,b=b,a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=1</span><br><span class="line">&gt;&gt;&gt; b=2</span><br><span class="line">&gt;&gt;&gt; a,b=b,a</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>5.’内容’.join([string array])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;.&apos;.join[2,3,4,5,6]  </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;builtin_function_or_method&apos; object has no attribute &apos;__getitem__&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;.&apos;.join([2,3,4,5,6]) </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: sequence item 0: expected string, int found</span><br><span class="line">&gt;&gt;&gt; &apos;.&apos;.join([&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;]) </span><br><span class="line">&apos;2.3.4.5.6&apos;</span><br></pre></td></tr></table></figure><h3 id="数组顺序翻转"><a href="#数组顺序翻转" class="headerlink" title="数组顺序翻转"></a>数组顺序翻转</h3><p>排序：<a href="https://blog.csdn.net/u014292358/article/details/79503397" target="_blank" rel="noopener">https://blog.csdn.net/u014292358/article/details/79503397</a><br>OpenCV与Python之图像的读入与显示以及利用Numpy的图像转换：<a href="https://www.cnblogs.com/visionfeng/p/6094423.html" target="_blank" rel="noopener">https://www.cnblogs.com/visionfeng/p/6094423.html</a></p><pre><code># Convert from RGB -&gt; BGRinput_a = input_a[..., [2, 1, 0]]input_b = input_b[..., [2, 1, 0]]</code></pre><p>###参考资料：<br>[1] <a href="https://blog.csdn.net/Sasoritattoo/article/details/12451359" target="_blank" rel="noopener">python代码<code>if not x:</code> 和<code>if x is not None:</code>和<code>if not x is None:</code>使用</a><br>[2] [python里面的几个用法，not in，c if a else b，[fun(a) for a in […]] , a,b=b,a,’内容’.join(string array)](<a href="https://blog.csdn.net/u013176681/article/details/53995190" target="_blank" rel="noopener">https://blog.csdn.net/u013176681/article/details/53995190</a>)[3] <a href="https://blog.csdn.net/zl87758539/article/details/51675628" target="_blank" rel="noopener">Python if 和 for 的多种写法</a></p>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摸鱼日志 </tag>
            
            <tag> XJBX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>光谱响应与量子效率</title>
      <link href="/2018/04/18/QE.html"/>
      <url>/2018/04/18/QE.html</url>
      <content type="html"><![CDATA[<p>##光谱响应<br>光谱响应单位为A/W,直观物理意义是单位功率下产生的电流响应。</p><p>##量子效率<br>量子效率分为外量子效率和内量子效率<br>一般量子效率指外量子效率，是指单位时间内外电路中产生的电子数与单位时间内的入射单色光子数之比。<br>内量子效率的定义为：单位时间内外电路中产生的电子书与单位时间内的入射（<strong>有效</strong>）单色光子数之比。<br>比较两个定义，可以看出内量子效应强调的是<strong>有效</strong>两字。那么<strong>无效</strong>的部分就是指因为反射或者投射等不被sensor所接收的光子了。</p><p>##二者关系<br>量子效率定义中，单位时间内的电子数 即为 的电流 。<br>光谱响应定义中，也有关于电流的概念：单位功率下产生的电流。</p><p>所以，量子效率 = (1240 * 光谱响应)/响应波长</p><p>E=hv=hc/λ, h和c是常量，把数值带进去。注意：因为最后E的单位是eV，λ的单位是nm，所以在中间会涉及单位的转换。<br>h = 6.626196×10^-34 J.s， c = 3×10^8 m/s， 上面的单位是ev，所以还要除以1.6×10^-19 c，λ的单位nm换成m还要乘以1×10^9，最后就得到1240/λ eV</p><a id="more"></a><p><strong>有时候会把两个概念混为一谈</strong></p><p>光谱响应  量子效率</p><p>光谱响应指光阴极量子效率与入射波长之间的关系<br>光谱响应表示不同波长的光子产生电子-空穴对的能力。定量地说，太阳电池的光谱响应就是当某一波长的光照射在电池表面上时，每一光子平均所能收集到的载流子数。太阳电池的光谱响应又分为绝对光谱响应和相对光谱响应。各种波长的单位辐射光能或对应的光子入射到太阳电池上，将产生不同的短路电流，按波长的分布求得其对应的短路电流变化曲线称为太阳电池的绝对光谱响应。如果每一波长以一定等量的辐射光能或等光子数入射到太阳电池上，所产生的短路电流与其中最大短路电流比较，按波长的分布求得其比值变化曲线，这就是该太阳电池的相对光谱响应。但是，无论是绝对还是相对光谱响应，光谱响应曲线峰值越高，越平坦，对应电池的短路电流密度就越大，效率也越高。</p><p>##参考资料<br>[1] <a href="http://muchong.com/html/201309/6391286.html" target="_blank" rel="noopener">http://muchong.com/html/201309/6391286.html</a><br>[2] <a href="https://baike.baidu.com/item/%E9%87%8F%E5%AD%90%E6%95%88%E7%8E%87/3641896?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%87%8F%E5%AD%90%E6%95%88%E7%8E%87/3641896?fr=aladdin</a><br>[3] <a href="https://www.jianshu.com/p/0864630e5fe4" target="_blank" rel="noopener">https://www.jianshu.com/p/0864630e5fe4</a></p>]]></content>
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> XJBX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MATLAB读取曲线图并重新绘制</title>
      <link href="/2018/04/08/MatlabRePlot.html"/>
      <url>/2018/04/08/MatlabRePlot.html</url>
      <content type="html"><![CDATA[<p>最近需要从datasheet中读取某款相机的光谱响应曲线，发现下面这段代码<a href="[用matlab提取jpg曲线数据或者jpg图片重新复原](https://www.cnblogs.com/Kermit-Li/p/6829778.html)">^1</a>。但是最后发现和自己的需求并不匹配，自己是要最终求出曲线的函数，完成由离散的点到数学公式的转换过程。这个小demo能够实现的仅仅是re-draw the pictures.仍旧记之。</p><a id="more"></a><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">I = imread(<span class="string">'target.png'</span>);<span class="comment">%读取处理好的图片，必须是严格坐标轴线为边界的图片</span></span><br><span class="line">I=rgb2gray(I);           <span class="comment">%灰度变化</span></span><br><span class="line">I(I&gt;<span class="number">200</span>)=<span class="number">255</span>;           <span class="comment">%二值化</span></span><br><span class="line">I(I&lt;=<span class="number">200</span>)=<span class="number">0</span>;            <span class="comment">%二值化</span></span><br><span class="line">imshow(I)                 <span class="comment">%显示图片</span></span><br><span class="line">figure;</span><br><span class="line">[y,x] = <span class="built_in">find</span>(I==<span class="number">0</span>);     <span class="comment">%找出曲线的像素位置</span></span><br><span class="line">y = max(y) -y;           <span class="comment">%将屏幕坐标转换为有手系迪卡坐标</span></span><br><span class="line">plot(x,y,<span class="string">'r.'</span>,<span class="string">'markersize'</span>,<span class="number">2</span>)<span class="comment">%显示转换后的图像</span></span><br><span class="line">[Xx,Yy]= ginput(<span class="number">2</span>);       <span class="comment">% 读取真是坐标左上角和右下角的两点</span></span><br><span class="line">min_x = min(Xx);</span><br><span class="line">max_x = max(Xx);</span><br><span class="line">min_y= min(Yy);</span><br><span class="line">max_y = max(Yy);</span><br><span class="line"><span class="comment">% x1 = (x-Xx(1))*(max_x-min_x)/(Xx(2)- Xx(1))+min_x;</span></span><br><span class="line"><span class="comment">% y1 = (y-Yy(1))*(min_y-max_y)/(Yy(2)- Yy(1))+max_y;</span></span><br><span class="line"><span class="comment">%% 坐标变化，如果坐标原点不为0，则需在该轴加上省去的坐标轴数</span></span><br><span class="line">xo = <span class="number">0</span>;<span class="comment">%原始图像起点坐标x</span></span><br><span class="line">yo = <span class="number">0</span>;<span class="comment">%原始图像起点坐标x</span></span><br><span class="line">xl = <span class="number">3</span>;    <span class="comment">%原始图像x轴长</span></span><br><span class="line">yl=<span class="number">25</span>;      <span class="comment">%原始图像y轴长</span></span><br><span class="line">x1 = (x - min(Xx))*xl/(max(Xx)-min(Xx))+xo ;<span class="comment">%数据点x值</span></span><br><span class="line">y1 = (y - min(Yy))*yl/(max(Yy)-min(Yy))+yo;<span class="comment">%数据点y值</span></span><br><span class="line">plot(x1,y1,<span class="string">'r.'</span>,<span class="string">'markersize'</span>,<span class="number">2</span>)</span><br><span class="line">axis([<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">25</span>])</span><br></pre></td></tr></table></figure><p>原图：<br><img src="https://upload-images.jianshu.io/upload_images/10342473-f5d64bb515e856ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图"><br>效果图：<br><img src="https://upload-images.jianshu.io/upload_images/10342473-77f3b13d4c05b48b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> XJBX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello Hexo!</title>
      <link href="/2018/03/27/hello-hexo.html"/>
      <url>/2018/03/27/hello-hexo.html</url>
      <content type="html"><![CDATA[<p>hello, welcome!</p>]]></content>
      
      
        <tags>
            
            <tag> 摸鱼日志 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
